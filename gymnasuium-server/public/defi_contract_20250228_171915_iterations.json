{
  "version": "1.0",
  "created_at": "2025-02-28T17:19:15.813381",
  "description": "Sui Move compiler error prediction dataset",
  "examples": [
    {
      "input": "module temp_addr::my_module {\n\n    use std::signer;\n\n    // A simple helper function to return the minimum of two u64 values.\n    fun min(a: u64, b: u64): u64 {\n        if (a < b) { a } else { b }\n    }\n\n    // A simple iterative algorithm to compute the integer square root of a u64.\n    // This is used to initialize liquidity shares based on the geometric mean.\n    public fun sqrt(n: u64): u64 {\n        if (n < 2) {\n            n\n        } else {\n            let mut x = n;\n            let mut y = (x + 1) / 2;\n            while (y < x) {\n                x = y;\n                y = (x + n / x) / 2;\n            }\n            x\n        }\n    }\n\n    // Resource representing a liquidity pool for two tokens.\n    // The pool tracks reserves for TokenA and TokenB, the fee rate (in percent),\n    // accumulated fees for each token, total liquidity shares, and an admin address.\n    resource struct LiquidityPool<TokenA, TokenB> has key {\n        reserve_a: u64,\n        reserve_b: u64,\n        fee_rate: u64,    // Fee rate as a percentage (e.g., 1 means 1% fee)\n        fee_a: u64,       // Accumulated fees for TokenA from swaps\n        fee_b: u64,       // Accumulated fees for TokenB from swaps\n        total_shares: u64, // Total liquidity shares issued\n        admin: address    // Admin address allowed to collect fees\n    }\n\n    // Resource representing liquidity provider (LP) tokens.\n    // These tokens grant the holder a share in the liquidity pool.\n    resource struct LPToken<TokenA, TokenB> has key {\n        share: u64\n    }\n\n    /////////////////////////////////////////////////////////////////////////////\n    // Initialization Functions\n    /////////////////////////////////////////////////////////////////////////////\n\n    // Function to create a new liquidity pool.\n    // The creator supplies initial amounts for TokenA and TokenB reserves and sets the fee rate.\n    // The initial LP share is computed as the integer square root of (initial_a * initial_b).\n    public fun create_pool<TokenA, TokenB>(\n        admin: &signer,\n        initial_a: u64,\n        initial_b: u64,\n        fee_rate: u64\n    ): (LiquidityPool<TokenA, TokenB>, LPToken<TokenA, TokenB>) {\n        // Ensure that initial liquidity amounts are positive.\n        assert!(initial_a > 0, 1);\n        assert!(initial_b > 0, 2);\n        // Compute initial liquidity share using the geometric mean.\n        let initial_shares = sqrt(initial_a * initial_b);\n\n        let pool = LiquidityPool<TokenA, TokenB> {\n            reserve_a: initial_a,\n            reserve_b: initial_b,\n            fee_rate: fee_rate,\n            fee_a: 0,\n            fee_b: 0,\n            total_shares: initial_shares,\n            admin: signer::address_of(admin)\n        };\n\n        let lp_token = LPToken<TokenA, TokenB> {\n            share: initial_shares\n        };\n\n        (pool, lp_token)\n    }\n\n    /////////////////////////////////////////////////////////////////////////////\n    // Liquidity Management Functions\n    /////////////////////////////////////////////////////////////////////////////\n\n    // Function for liquidity providers to add liquidity to the pool.\n    // Liquidity must be provided in the same ratio as the current pool reserves.\n    // Returns a new LPToken representing the liquidity provider's share.\n    public fun add_liquidity<TokenA, TokenB>(\n        pool: &mut LiquidityPool<TokenA, TokenB>,\n        amount_a: u64,\n        amount_b: u64\n    ): LPToken<TokenA, TokenB> {\n        // When the pool already has liquidity, require that the provided amounts match the pool ratio.\n        if (pool.reserve_a != 0 && pool.reserve_b != 0) {\n            // Enforce ratio equality: amount_a/reserve_a must equal amount_b/reserve_b.\n            // To avoid division, cross-multiply and compare.\n            assert!(amount_a * pool.reserve_b == amount_b * pool.reserve_a, 100);\n        }\n\n        let share: u64;\n        if (pool.total_shares == 0) {\n            share = sqrt(amount_a * amount_b);\n        } else {\n            // Calculate the share tokens to mint as the minimum of:\n            // amount_a * total_shares / reserve_a and amount_b * total_shares / reserve_b.\n            let share_a = amount_a * pool.total_shares / pool.reserve_a;\n            let share_b = amount_b * pool.total_shares / pool.reserve_b;\n            share = min(share_a, share_b);\n        }\n\n        // Update pool reserves and total shares.\n        pool.reserve_a = pool.reserve_a + amount_a;\n        pool.reserve_b = pool.reserve_b + amount_b;\n        pool.total_shares = pool.total_shares + share;\n\n        LPToken<TokenA, TokenB> { share }\n    }\n\n    // Function for liquidity providers to remove liquidity from the pool.\n    // The provider supplies LPToken and receives TokenA and TokenB amounts proportionally.\n    public fun remove_liquidity<TokenA, TokenB>(\n        pool: &mut LiquidityPool<TokenA, TokenB>,\n        lp: LPToken<TokenA, TokenB>\n    ): (u64, u64) {\n        let share = lp.share;\n        // Calculate amounts to withdraw based on the share of total liquidity.\n        let amount_a = share * pool.reserve_a / pool.total_shares;\n        let amount_b = share * pool.reserve_b / pool.total_shares;\n\n        // Update the pool state.\n        pool.reserve_a = pool.reserve_a - amount_a;\n        pool.reserve_b = pool.reserve_b - amount_b;\n        pool.total_shares = pool.total_shares - share;\n\n        // Destroy the LP token by simply consuming it (Move will drop it).\n        (amount_a, amount_b)\n    }\n\n    /////////////////////////////////////////////////////////////////////////////\n    // Swap Functions\n    /////////////////////////////////////////////////////////////////////////////\n\n    // Swap function to exchange TokenA for TokenB.\n    // The swap uses a simple constant product formula and charges a fee.\n    // The fee (as a percentage) is deducted from the input amount.\n    // Returns the output amount of TokenB.\n    public fun swap_a_to_b<TokenA, TokenB>(\n        pool: &mut LiquidityPool<TokenA, TokenB>,\n        amount_in: u64\n    ): u64 {\n        // Ensure that the input amount is positive.\n        assert!(amount_in > 0, 200);\n\n        // Compute fee and net input.\n        let fee = amount_in * pool.fee_rate / 100;\n        let net_in = amount_in - fee;\n\n        let old_reserve_a = pool.reserve_a;\n        let old_reserve_b = pool.reserve_b;\n\n        // The invariant k = reserve_a * reserve_b is maintained (ignoring fees).\n        let k = old_reserve_a * old_reserve_b;\n\n        let new_reserve_a = old_reserve_a + net_in;\n        // Ensure new_reserve_a is not zero.\n        assert!(new_reserve_a > 0, 201);\n\n        let new_reserve_b = k / new_reserve_a;\n        // The output amount is the reduction in TokenB reserve.\n        // Ensure that the result does not exceed the available reserve.\n        assert!(old_reserve_b > new_reserve_b, 202);\n        let amount_out = old_reserve_b - new_reserve_b;\n\n        // Update pool reserves.\n        pool.reserve_a = new_reserve_a;\n        pool.reserve_b = new_reserve_b;\n        // Accumulate the fee for TokenA.\n        pool.fee_a = pool.fee_a + fee;\n\n        amount_out\n    }\n\n    // Swap function to exchange TokenB for TokenA.\n    // Uses a constant product formula with fee deduction.\n    // Returns the output amount of TokenA.\n    public fun swap_b_to_a<TokenA, TokenB>(\n        pool: &mut LiquidityPool<TokenA, TokenB>,\n        amount_in: u64\n    ): u64 {\n        // Ensure that the input amount is positive.\n        assert!(amount_in > 0, 300);\n\n        // Compute fee and net input.\n        let fee = amount_in * pool.fee_rate / 100;\n        let net_in = amount_in - fee;\n\n        let old_reserve_b = pool.reserve_b;\n        let old_reserve_a = pool.reserve_a;\n\n        let k = old_reserve_a * old_reserve_b;\n\n        let new_reserve_b = old_reserve_b + net_in;\n        assert!(new_reserve_b > 0, 301);\n\n        let new_reserve_a = k / new_reserve_b;\n        assert!(old_reserve_a > new_reserve_a, 302);\n        let amount_out = old_reserve_a - new_reserve_a;\n\n        // Update pool reserves.\n        pool.reserve_b = new_reserve_b;\n        pool.reserve_a = new_reserve_a;\n        // Accumulate the fee for TokenB.\n        pool.fee_b = pool.fee_b + fee;\n\n        amount_out\n    }\n\n    /////////////////////////////////////////////////////////////////////////////\n    // Fee Collection Function\n    /////////////////////////////////////////////////////////////////////////////\n\n    // Admin function to collect the accumulated fees.\n    // Only the admin that created the pool can call this function.\n    // Returns a tuple with the collected fees for TokenA and TokenB, and resets the fee counters.\n    public fun collect_fees<TokenA, TokenB>(\n        pool: &mut LiquidityPool<TokenA, TokenB>,\n        admin: &signer\n    ): (u64, u64) {\n        // Verify that the caller is the admin.\n        let caller = signer::address_of(admin);\n        assert!(caller == pool.admin, 400);\n\n        let fees_a = pool.fee_a;\n        let fees_b = pool.fee_b;\n\n        // Reset the fee accumulators.\n        pool.fee_a = 0;\n        pool.fee_b = 0;\n\n        (fees_a, fees_b)\n    }\n}\n",
      "output": "UPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git\nINCLUDING DEPENDENCY Sui\nINCLUDING DEPENDENCY MoveStdlib\nBUILDING TempContract\nerror[E03002]: unbound module\n  \u250c\u2500 ./sources/temp_contract.move:3:9\n  \u2502\n3 \u2502     use std::signer;\n  \u2502         ^^^^^^^^^^^ Invalid 'use'. Unbound module: 'std::signer'\n\nerror[E01002]: unexpected token\n   \u250c\u2500 ./sources/temp_contract.move:22:13\n   \u2502\n22 \u2502             x\n   \u2502             ^\n   \u2502             \u2502\n   \u2502             Unexpected 'x'\n   \u2502             Expected ';'\n\nerror[E01002]: unexpected token\n   \u250c\u2500 ./sources/temp_contract.move:29:5\n   \u2502\n29 \u2502     resource struct LiquidityPool<TokenA, TokenB> has key {\n   \u2502     ^^^^^^^^\n   \u2502     \u2502\n   \u2502     Unexpected 'resource'\n   \u2502     Expected a module member: 'spec', 'use', 'friend', 'const', 'fun', 'struct', or 'enum'\n\nerror[E01003]: invalid modifier\n   \u250c\u2500 ./sources/temp_contract.move:29:14\n   \u2502\n29 \u2502     resource struct LiquidityPool<TokenA, TokenB> has key {\n   \u2502              ^^^^^^ Invalid struct declaration. Internal struct declarations are not yet supported\n   \u2502\n   = Visibility annotations are required on struct declarations from the Move 2024 edition onwards.\n\nwarning[W09006]: unused struct type parameter\n   \u250c\u2500 ./sources/temp_contract.move:29:35\n   \u2502\n29 \u2502     resource struct LiquidityPool<TokenA, TokenB> has key {\n   \u2502                                   ^^^^^^ Unused type parameter 'TokenA'. Consider declaring it as phantom\n   \u2502\n   = This warning can be suppressed with '#[allow(unused_type_parameter)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nwarning[W09006]: unused struct type parameter\n   \u250c\u2500 ./sources/temp_contract.move:29:43\n   \u2502\n29 \u2502     resource struct LiquidityPool<TokenA, TokenB> has key {\n   \u2502                                           ^^^^^^ Unused type parameter 'TokenB'. Consider declaring it as phantom\n   \u2502\n   = This warning can be suppressed with '#[allow(unused_type_parameter)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nerror[Sui E02007]: invalid object declaration\n   \u250c\u2500 ./sources/temp_contract.move:30:9\n   \u2502\n29 \u2502     resource struct LiquidityPool<TokenA, TokenB> has key {\n   \u2502                                                       --- The 'key' ability is used to declare objects in Sui\n30 \u2502         reserve_a: u64,\n   \u2502         ^^^^^^^^^ Invalid object 'LiquidityPool'. Structs with the 'key' ability must have 'id: sui::object::UID' as their first field\n\nerror[E01002]: unexpected token\n   \u250c\u2500 ./sources/temp_contract.move:41:5\n   \u2502\n41 \u2502     resource struct LPToken<TokenA, TokenB> has key {\n   \u2502     ^^^^^^^^\n   \u2502     \u2502\n   \u2502     Unexpected 'resource'\n   \u2502     Expected a module member: 'spec', 'use', 'friend', 'const', 'fun', 'struct', or 'enum'\n\nerror[E01003]: invalid modifier\n   \u250c\u2500 ./sources/temp_contract.move:41:14\n   \u2502\n41 \u2502     resource struct LPToken<TokenA, TokenB> has key {\n   \u2502              ^^^^^^ Invalid struct declaration. Internal struct declarations are not yet supported\n   \u2502\n   = Visibility annotations are required on struct declarations from the Move 2024 edition onwards.\n\nwarning[W09006]: unused struct type parameter\n   \u250c\u2500 ./sources/temp_contract.move:41:29\n   \u2502\n41 \u2502     resource struct LPToken<TokenA, TokenB> has key {\n   \u2502                             ^^^^^^ Unused type parameter 'TokenA'. Consider declaring it as phantom\n   \u2502\n   = This warning can be suppressed with '#[allow(unused_type_parameter)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nwarning[W09006]: unused struct type parameter\n   \u250c\u2500 ./sources/temp_contract.move:41:37\n   \u2502\n41 \u2502     resource struct LPToken<TokenA, TokenB> has key {\n   \u2502                                     ^^^^^^ Unused type parameter 'TokenB'. Consider declaring it as phantom\n   \u2502\n   = This warning can be suppressed with '#[allow(unused_type_parameter)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nerror[Sui E02007]: invalid object declaration\n   \u250c\u2500 ./sources/temp_contract.move:42:9\n   \u2502\n41 \u2502     resource struct LPToken<TokenA, TokenB> has key {\n   \u2502                                                 --- The 'key' ability is used to declare objects in Sui\n42 \u2502         share: u64\n   \u2502         ^^^^^ Invalid object 'LPToken'. Structs with the 'key' ability must have 'id: sui::object::UID' as their first field\n\nwarning[W09002]: unused variable\n   \u250c\u2500 ./sources/temp_contract.move:53:9\n   \u2502\n53 \u2502         admin: &signer,\n   \u2502         ^^^^^ Unused parameter 'admin'. Consider removing or prefixing with an underscore: '_admin'\n   \u2502\n   = This warning can be suppressed with '#[allow(unused_variable)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nerror[E03006]: unexpected name in this position\n   \u250c\u2500 ./sources/temp_contract.move:71:20\n   \u2502\n71 \u2502             admin: signer::address_of(admin)\n   \u2502                    ^^^^^^ Could not resolve the name 'signer'\n\nerror[E01002]: unexpected token\n    \u250c\u2500 ./sources/temp_contract.move:100:9\n    \u2502\n100 \u2502         let share: u64;\n    \u2502         ^^^\n    \u2502         \u2502\n    \u2502         Unexpected 'let'\n    \u2502         Expected ';'\n\nerror[E01002]: unexpected token\n    \u250c\u2500 ./sources/temp_contract.move:112:9\n    \u2502\n112 \u2502         pool.reserve_a = pool.reserve_a + amount_a;\n    \u2502         ^^^^\n    \u2502         \u2502\n    \u2502         Unexpected 'pool'\n    \u2502         Expected ';'\n\nwarning[W09002]: unused variable\n    \u250c\u2500 ./sources/temp_contract.move:227:9\n    \u2502\n227 \u2502         admin: &signer\n    \u2502         ^^^^^ Unused parameter 'admin'. Consider removing or prefixing with an underscore: '_admin'\n    \u2502\n    = This warning can be suppressed with '#[allow(unused_variable)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nerror[E03006]: unexpected name in this position\n    \u250c\u2500 ./sources/temp_contract.move:230:22\n    \u2502\n230 \u2502         let caller = signer::address_of(admin);\n    \u2502                      ^^^^^^ Could not resolve the name 'signer'\n\n",
      "metadata": {
        "iteration": 1,
        "timestamp": 1740791812.079616,
        "error_stats": {
          "errors": 18,
          "compiler_warnings": 6,
          "linter_warnings": 0
        },
        "error_codes": {
          "E02003": {
            "count": 1,
            "message": "unbound module",
            "level": "BlockingError"
          },
          "N02001": {
            "count": 5,
            "message": "unexpected token",
            "level": "NonblockingError"
          },
          "N03001": {
            "count": 2,
            "message": "invalid modifier",
            "level": "NonblockingError"
          },
          "W06009": {
            "count": 4,
            "message": "unused struct type parameter",
            "level": "Warning"
          },
          "N07002": {
            "count": 2,
            "message": "invalid object declaration",
            "level": "NonblockingError"
          },
          "W02009": {
            "count": 2,
            "message": "unused variable",
            "level": "Warning"
          },
          "E06003": {
            "count": 2,
            "message": "unexpected name in this position",
            "level": "BlockingError"
          }
        }
      }
    },
    {
      "input": "module temp_addr::my_module {\n\n    // Import UID for object identification and TxContext for transaction context handling.\n    use sui::object::UID;\n    use sui::tx_context::TxContext;\n\n    // Allow unused type parameters for TokenA and TokenB.\n    #[allow(unused_type_parameters)]\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Helper Functions\n    ///////////////////////////////////////////////////////////////////////////\n\n    // Returns the minimum of two u64 values.\n    public fun min(a: u64, b: u64): u64 {\n        if (a < b) { \n            a \n        } else { \n            b \n        }\n    }\n\n    // Computes the integer square root of n using Newton's method.\n    public fun sqrt(n: u64): u64 {\n        if (n < 2) {\n            n\n        } else {\n            let mut x = n;\n            let mut y = (x + 1) / 2;\n            // Loop until convergence.\n            while (y < x) {\n                x = y;\n                y = (x + n / x) / 2;\n            };\n            x\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Resource Definitions\n    ///////////////////////////////////////////////////////////////////////////\n\n    // Resource representing a liquidity pool for two tokens.\n    // Note: Structures with the 'key' ability in Sui must have an 'id: UID' field as the first field.\n    resource struct LiquidityPool<TokenA, TokenB> has key {\n        id: UID,\n        reserve_a: u64,\n        reserve_b: u64,\n        fee_rate: u64,     // Fee rate percentage (e.g., 1 means 1%)\n        fee_a: u64,        // Accumulated fees for TokenA\n        fee_b: u64,        // Accumulated fees for TokenB\n        total_shares: u64, // Total LP shares issued\n        admin: address     // Admin address allowed to collect fees\n    }\n\n    // Resource representing liquidity provider (LP) tokens.\n    resource struct LPToken<TokenA, TokenB> has key {\n        id: UID,\n        share: u64\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Initialization Functions\n    ///////////////////////////////////////////////////////////////////////////\n\n    // Creates a new liquidity pool.\n    // The creator provides initial TokenA and TokenB amounts and sets the fee rate.\n    // The initial liquidity shares are computed as the square root of (initial_a * initial_b).\n    public fun create_pool<TokenA, TokenB>(\n        ctx: &mut TxContext,\n        initial_a: u64,\n        initial_b: u64,\n        fee_rate: u64\n    ): (LiquidityPool<TokenA, TokenB>, LPToken<TokenA, TokenB>) {\n        // Ensure that initial liquidity amounts are positive.\n        assert!(initial_a > 0, 1);\n        assert!(initial_b > 0, 2);\n        let initial_shares = sqrt(initial_a * initial_b);\n\n        let pool = LiquidityPool<TokenA, TokenB> {\n            id: UID::new(ctx),\n            reserve_a: initial_a,\n            reserve_b: initial_b,\n            fee_rate: fee_rate,\n            fee_a: 0,\n            fee_b: 0,\n            total_shares: initial_shares,\n            admin: TxContext::sender(ctx)\n        };\n\n        let lp_token = LPToken<TokenA, TokenB> {\n            id: UID::new(ctx),\n            share: initial_shares\n        };\n\n        (pool, lp_token)\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Liquidity Management Functions\n    ///////////////////////////////////////////////////////////////////////////\n\n    // Adds liquidity to the pool.\n    // Liquidity must be provided in the same ratio as the current pool reserves.\n    // Returns a new LPToken representing the liquidity provider's share.\n    public fun add_liquidity<TokenA, TokenB>(\n        ctx: &mut TxContext,\n        pool: &mut LiquidityPool<TokenA, TokenB>,\n        amount_a: u64,\n        amount_b: u64\n    ): LPToken<TokenA, TokenB> {\n        // When the pool already has liquidity, ensure the provided amounts match the pool ratio.\n        if (pool.reserve_a != 0 && pool.reserve_b != 0) {\n            // Enforce ratio equality by cross-multiplication.\n            assert!(amount_a * pool.reserve_b == amount_b * pool.reserve_a, 100);\n        };\n\n        let share: u64;\n        if (pool.total_shares == 0) {\n            share = sqrt(amount_a * amount_b);\n        } else {\n            // Calculate shares to mint as the minimum of the proportional contributions.\n            let share_a = amount_a * pool.total_shares / pool.reserve_a;\n            let share_b = amount_b * pool.total_shares / pool.reserve_b;\n            share = min(share_a, share_b);\n        };\n\n        // Update pool reserves and total shares.\n        pool.reserve_a = pool.reserve_a + amount_a;\n        pool.reserve_b = pool.reserve_b + amount_b;\n        pool.total_shares = pool.total_shares + share;\n\n        let lp_token = LPToken<TokenA, TokenB> {\n            id: UID::new(ctx),\n            share: share\n        };\n        lp_token\n    }\n\n    // Removes liquidity from the pool.\n    // The provider supplies LPToken and receives corresponding TokenA and TokenB amounts.\n    public fun remove_liquidity<TokenA, TokenB>(\n        pool: &mut LiquidityPool<TokenA, TokenB>,\n        lp: LPToken<TokenA, TokenB>\n    ): (u64, u64) {\n        let share = lp.share;\n        // Calculate withdrawal amounts proportionally.\n        let amount_a = share * pool.reserve_a / pool.total_shares;\n        let amount_b = share * pool.reserve_b / pool.total_shares;\n\n        // Update pool state.\n        pool.reserve_a = pool.reserve_a - amount_a;\n        pool.reserve_b = pool.reserve_b - amount_b;\n        pool.total_shares = pool.total_shares - share;\n\n        (amount_a, amount_b)\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Swap Functions\n    ///////////////////////////////////////////////////////////////////////////\n\n    // Swaps TokenA for TokenB using a constant product formula with fee deduction.\n    // Returns the amount of TokenB output.\n    public fun swap_a_to_b<TokenA, TokenB>(\n        pool: &mut LiquidityPool<TokenA, TokenB>,\n        amount_in: u64\n    ): u64 {\n        // Ensure input amount is positive.\n        assert!(amount_in > 0, 200);\n\n        let fee = amount_in * pool.fee_rate / 100;\n        let net_in = amount_in - fee;\n\n        let old_reserve_a = pool.reserve_a;\n        let old_reserve_b = pool.reserve_b;\n\n        // Constant product invariant: k = reserve_a * reserve_b.\n        let k = old_reserve_a * old_reserve_b;\n\n        let new_reserve_a = old_reserve_a + net_in;\n        assert!(new_reserve_a > 0, 201);\n\n        let new_reserve_b = k / new_reserve_a;\n        assert!(old_reserve_b > new_reserve_b, 202);\n        let amount_out = old_reserve_b - new_reserve_b;\n\n        // Update pool reserves.\n        pool.reserve_a = new_reserve_a;\n        pool.reserve_b = new_reserve_b;\n        // Accumulate the fee for TokenA.\n        pool.fee_a = pool.fee_a + fee;\n\n        amount_out\n    }\n\n    // Swaps TokenB for TokenA using a constant product formula with fee deduction.\n    // Returns the amount of TokenA output.\n    public fun swap_b_to_a<TokenA, TokenB>(\n        pool: &mut LiquidityPool<TokenA, TokenB>,\n        amount_in: u64\n    ): u64 {\n        // Ensure input amount is positive.\n        assert!(amount_in > 0, 300);\n\n        let fee = amount_in * pool.fee_rate / 100;\n        let net_in = amount_in - fee;\n\n        let old_reserve_b = pool.reserve_b;\n        let old_reserve_a = pool.reserve_a;\n\n        let k = old_reserve_a * old_reserve_b;\n\n        let new_reserve_b = old_reserve_b + net_in;\n        assert!(new_reserve_b > 0, 301);\n\n        let new_reserve_a = k / new_reserve_b;\n        assert!(old_reserve_a > new_reserve_a, 302);\n        let amount_out = old_reserve_a - new_reserve_a;\n\n        // Update pool reserves.\n        pool.reserve_b = new_reserve_b;\n        pool.reserve_a = new_reserve_a;\n        // Accumulate the fee for TokenB.\n        pool.fee_b = pool.fee_b + fee;\n\n        amount_out\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Fee Collection Function\n    ///////////////////////////////////////////////////////////////////////////\n\n    // Allows the admin to collect accumulated fees from the liquidity pool.\n    // Only the admin (creator) of the pool can call this function.\n    public fun collect_fees<TokenA, TokenB>(\n        pool: &mut LiquidityPool<TokenA, TokenB>,\n        ctx: &mut TxContext\n    ): (u64, u64) {\n        let caller = TxContext::sender(ctx);\n        assert!(caller == pool.admin, 400);\n\n        let fees_a = pool.fee_a;\n        let fees_b = pool.fee_b;\n\n        // Reset fee accumulators.\n        pool.fee_a = 0;\n        pool.fee_b = 0;\n\n        (fees_a, fees_b)\n    }\n}",
      "output": "UPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git\nINCLUDING DEPENDENCY Sui\nINCLUDING DEPENDENCY MoveStdlib\nBUILDING TempContract\nwarning[W02021]: duplicate alias\n  \u250c\u2500 ./sources/temp_contract.move:4:22\n  \u2502\n4 \u2502     use sui::object::UID;\n  \u2502                      ^^^ Unnecessary alias 'UID' for module member 'sui::object::UID'. This alias is provided by default\n  \u2502\n  = This warning can be suppressed with '#[allow(duplicate_alias)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nwarning[W02021]: duplicate alias\n  \u250c\u2500 ./sources/temp_contract.move:5:26\n  \u2502\n5 \u2502     use sui::tx_context::TxContext;\n  \u2502                          ^^^^^^^^^ Unnecessary alias 'TxContext' for module member 'sui::tx_context::TxContext'. This alias is provided by default\n  \u2502\n  = This warning can be suppressed with '#[allow(duplicate_alias)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nwarning[W10007]: issue with attribute value\n  \u250c\u2500 ./sources/temp_contract.move:8:13\n  \u2502\n8 \u2502     #[allow(unused_type_parameters)]\n  \u2502             ^^^^^^^^^^^^^^^^^^^^^^ Unknown warning filter 'unused_type_parameters'\n\nerror[E01002]: unexpected token\n   \u250c\u2500 ./sources/temp_contract.move:45:5\n   \u2502\n45 \u2502     resource struct LiquidityPool<TokenA, TokenB> has key {\n   \u2502     ^^^^^^^^\n   \u2502     \u2502\n   \u2502     Unexpected 'resource'\n   \u2502     Expected a module member: 'spec', 'use', 'friend', 'const', 'fun', 'struct', or 'enum'\n\nerror[E01003]: invalid modifier\n   \u250c\u2500 ./sources/temp_contract.move:45:14\n   \u2502\n45 \u2502     resource struct LiquidityPool<TokenA, TokenB> has key {\n   \u2502              ^^^^^^ Invalid struct declaration. Internal struct declarations are not yet supported\n   \u2502\n   = Visibility annotations are required on struct declarations from the Move 2024 edition onwards.\n\nwarning[W09006]: unused struct type parameter\n   \u250c\u2500 ./sources/temp_contract.move:45:35\n   \u2502\n45 \u2502     resource struct LiquidityPool<TokenA, TokenB> has key {\n   \u2502                                   ^^^^^^ Unused type parameter 'TokenA'. Consider declaring it as phantom\n   \u2502\n   = This warning can be suppressed with '#[allow(unused_type_parameter)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nwarning[W09006]: unused struct type parameter\n   \u250c\u2500 ./sources/temp_contract.move:45:43\n   \u2502\n45 \u2502     resource struct LiquidityPool<TokenA, TokenB> has key {\n   \u2502                                           ^^^^^^ Unused type parameter 'TokenB'. Consider declaring it as phantom\n   \u2502\n   = This warning can be suppressed with '#[allow(unused_type_parameter)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nerror[E01002]: unexpected token\n   \u250c\u2500 ./sources/temp_contract.move:57:5\n   \u2502\n57 \u2502     resource struct LPToken<TokenA, TokenB> has key {\n   \u2502     ^^^^^^^^\n   \u2502     \u2502\n   \u2502     Unexpected 'resource'\n   \u2502     Expected a module member: 'spec', 'use', 'friend', 'const', 'fun', 'struct', or 'enum'\n\nerror[E01003]: invalid modifier\n   \u250c\u2500 ./sources/temp_contract.move:57:14\n   \u2502\n57 \u2502     resource struct LPToken<TokenA, TokenB> has key {\n   \u2502              ^^^^^^ Invalid struct declaration. Internal struct declarations are not yet supported\n   \u2502\n   = Visibility annotations are required on struct declarations from the Move 2024 edition onwards.\n\nwarning[W09006]: unused struct type parameter\n   \u250c\u2500 ./sources/temp_contract.move:57:29\n   \u2502\n57 \u2502     resource struct LPToken<TokenA, TokenB> has key {\n   \u2502                             ^^^^^^ Unused type parameter 'TokenA'. Consider declaring it as phantom\n   \u2502\n   = This warning can be suppressed with '#[allow(unused_type_parameter)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nwarning[W09006]: unused struct type parameter\n   \u250c\u2500 ./sources/temp_contract.move:57:37\n   \u2502\n57 \u2502     resource struct LPToken<TokenA, TokenB> has key {\n   \u2502                                     ^^^^^^ Unused type parameter 'TokenB'. Consider declaring it as phantom\n   \u2502\n   = This warning can be suppressed with '#[allow(unused_type_parameter)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nerror[E03006]: unexpected name in this position\n   \u250c\u2500 ./sources/temp_contract.move:81:17\n   \u2502\n81 \u2502             id: UID::new(ctx),\n   \u2502                 ^^^ Invalid construction. Expected an enum\n   \u2502\n   \u250c\u2500 /Users/kz/.move/https___github_com_MystenLabs_sui_git_framework__testnet/crates/sui-framework/packages/sui-framework/sources/object.move:69:15\n   \u2502\n69 \u2502 public struct UID has store {\n   \u2502               --- But 'UID' is an struct\n\nerror[E03006]: unexpected name in this position\n   \u250c\u2500 ./sources/temp_contract.move:88:20\n   \u2502\n88 \u2502             admin: TxContext::sender(ctx)\n   \u2502                    ^^^^^^^^^ Invalid construction. Expected an enum\n   \u2502\n   \u250c\u2500 /Users/kz/.move/https___github_com_MystenLabs_sui_git_framework__testnet/crates/sui-framework/packages/sui-framework/sources/tx_context.move:21:15\n   \u2502\n21 \u2502 public struct TxContext has drop {\n   \u2502               --------- But 'TxContext' is an struct\n\nerror[E03006]: unexpected name in this position\n   \u250c\u2500 ./sources/temp_contract.move:92:17\n   \u2502\n92 \u2502             id: UID::new(ctx),\n   \u2502                 ^^^ Invalid construction. Expected an enum\n   \u2502\n   \u250c\u2500 /Users/kz/.move/https___github_com_MystenLabs_sui_git_framework__testnet/crates/sui-framework/packages/sui-framework/sources/object.move:69:15\n   \u2502\n69 \u2502 public struct UID has store {\n   \u2502               --- But 'UID' is an struct\n\nerror[E03006]: unexpected name in this position\n    \u250c\u2500 ./sources/temp_contract.move:134:17\n    \u2502\n134 \u2502             id: UID::new(ctx),\n    \u2502                 ^^^ Invalid construction. Expected an enum\n    \u2502\n    \u250c\u2500 /Users/kz/.move/https___github_com_MystenLabs_sui_git_framework__testnet/crates/sui-framework/packages/sui-framework/sources/object.move:69:15\n    \u2502\n 69 \u2502 public struct UID has store {\n    \u2502               --- But 'UID' is an struct\n\nerror[E03006]: unexpected name in this position\n    \u250c\u2500 ./sources/temp_contract.move:240:22\n    \u2502\n240 \u2502         let caller = TxContext::sender(ctx);\n    \u2502                      ^^^^^^^^^ Invalid construction. Expected an enum\n    \u2502\n    \u250c\u2500 /Users/kz/.move/https___github_com_MystenLabs_sui_git_framework__testnet/crates/sui-framework/packages/sui-framework/sources/tx_context.move:21:15\n    \u2502\n 21 \u2502 public struct TxContext has drop {\n    \u2502               --------- But 'TxContext' is an struct\n\n",
      "metadata": {
        "iteration": 2,
        "timestamp": 1740791864.954842,
        "error_stats": {
          "errors": 16,
          "compiler_warnings": 7,
          "linter_warnings": 0
        },
        "error_codes": {
          "W21002": {
            "count": 2,
            "message": "duplicate alias",
            "level": "Warning"
          },
          "W07010": {
            "count": 1,
            "message": "issue with attribute value",
            "level": "Warning"
          },
          "N02001": {
            "count": 2,
            "message": "unexpected token",
            "level": "NonblockingError"
          },
          "N03001": {
            "count": 2,
            "message": "invalid modifier",
            "level": "NonblockingError"
          },
          "W06009": {
            "count": 4,
            "message": "unused struct type parameter",
            "level": "Warning"
          },
          "E06003": {
            "count": 5,
            "message": "unexpected name in this position",
            "level": "BlockingError"
          }
        }
      }
    },
    {
      "input": "module temp_addr::my_module {\n\n    // Import necessary functions and types from the Sui framework.\n    use sui::object::{UID, new};\n    use sui::tx_context::{TxContext, sender};\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Helper Functions\n    ///////////////////////////////////////////////////////////////////////////\n\n    // Returns the minimum of two u64 values.\n    public fun min(a: u64, b: u64): u64 {\n        if (a < b) { \n            a \n        } else { \n            b \n        }\n    }\n\n    // Computes the integer square root of n using Newton's method.\n    public fun sqrt(n: u64): u64 {\n        if (n < 2) {\n            n\n        } else {\n            let mut x = n;\n            let mut y = (x + 1) / 2;\n            while (y < x) {\n                x = y;\n                y = (x + n / x) / 2;\n            };\n            x\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Data Structures\n    ///////////////////////////////////////////////////////////////////////////\n\n    // LiquidityPool stores the state of the pool.\n    // Note: Objects with the 'key' ability must have an 'id: UID' field as the first field.\n    public struct LiquidityPool has key {\n        id: UID,\n        reserve_a: u64,\n        reserve_b: u64,\n        fee_rate: u64,     // Fee rate as a percentage (e.g., 1 means 1% fee)\n        fee_a: u64,        // Accumulated fees for TokenA from swaps\n        fee_b: u64,        // Accumulated fees for TokenB from swaps\n        total_shares: u64, // Total liquidity shares issued\n        admin: address     // Admin address allowed to collect fees\n    }\n\n    // LPToken represents the liquidity provider's share in the pool.\n    public struct LPToken has key {\n        id: UID,\n        share: u64\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Initialization Functions\n    ///////////////////////////////////////////////////////////////////////////\n\n    // create_pool initializes a new liquidity pool.\n    // The creator provides the initial amounts for TokenA and TokenB and the fee rate.\n    // The initial liquidity shares are computed as the square root of (initial_a * initial_b).\n    public fun create_pool(\n        ctx: &mut TxContext,\n        initial_a: u64,\n        initial_b: u64,\n        fee_rate: u64\n    ): (LiquidityPool, LPToken) {\n        // Ensure that initial liquidity amounts are positive.\n        assert!(initial_a > 0, 1);\n        assert!(initial_b > 0, 2);\n        let initial_shares = sqrt(initial_a * initial_b);\n\n        let pool = LiquidityPool {\n            id: new(ctx),\n            reserve_a: initial_a,\n            reserve_b: initial_b,\n            fee_rate: fee_rate,\n            fee_a: 0,\n            fee_b: 0,\n            total_shares: initial_shares,\n            admin: sender(ctx)\n        };\n\n        let lp_token = LPToken {\n            id: new(ctx),\n            share: initial_shares\n        };\n\n        (pool, lp_token)\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Liquidity Management Functions\n    ///////////////////////////////////////////////////////////////////////////\n\n    // add_liquidity allows liquidity providers to deposit additional funds into the pool.\n    // Liquidity must be provided in the same ratio as the current reserves.\n    // Returns an LPToken representing the provider's share.\n    public fun add_liquidity(\n        ctx: &mut TxContext,\n        pool: &mut LiquidityPool,\n        amount_a: u64,\n        amount_b: u64\n    ): LPToken {\n        // If the pool already has liquidity, enforce the ratio equality via cross multiplication.\n        if (pool.reserve_a != 0 && pool.reserve_b != 0) {\n            assert!(amount_a * pool.reserve_b == amount_b * pool.reserve_a, 100);\n        };\n\n        let share: u64 = if (pool.total_shares == 0) {\n            sqrt(amount_a * amount_b)\n        } else {\n            let share_a = amount_a * pool.total_shares / pool.reserve_a;\n            let share_b = amount_b * pool.total_shares / pool.reserve_b;\n            min(share_a, share_b)\n        };\n\n        // Update the pool's state.\n        pool.reserve_a = pool.reserve_a + amount_a;\n        pool.reserve_b = pool.reserve_b + amount_b;\n        pool.total_shares = pool.total_shares + share;\n\n        let lp_token = LPToken {\n            id: new(ctx),\n            share: share\n        };\n\n        lp_token\n    }\n\n    // remove_liquidity allows liquidity providers to withdraw their share from the pool.\n    // The provider supplies an LPToken and receives amounts of TokenA and TokenB proportionally.\n    public fun remove_liquidity(\n        pool: &mut LiquidityPool,\n        lp: LPToken\n    ): (u64, u64) {\n        let share = lp.share;\n        // Calculate the amounts to withdraw based on the provider's share.\n        let amount_a = share * pool.reserve_a / pool.total_shares;\n        let amount_b = share * pool.reserve_b / pool.total_shares;\n\n        // Update the pool state.\n        pool.reserve_a = pool.reserve_a - amount_a;\n        pool.reserve_b = pool.reserve_b - amount_b;\n        pool.total_shares = pool.total_shares - share;\n\n        // The LPToken is consumed/dropped.\n        (amount_a, amount_b)\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Swap Functions\n    ///////////////////////////////////////////////////////////////////////////\n\n    // swap_a_to_b allows a user to swap TokenA for TokenB.\n    // A fee is deducted from the input amount. The swap uses a constant product pricing formula.\n    // Returns the amount of TokenB output.\n    public fun swap_a_to_b(\n        pool: &mut LiquidityPool,\n        amount_in: u64\n    ): u64 {\n        // Ensure the input amount is positive.\n        assert!(amount_in > 0, 200);\n\n        // Calculate fee and net input.\n        let fee = amount_in * pool.fee_rate / 100;\n        let net_in = amount_in - fee;\n\n        let old_reserve_a = pool.reserve_a;\n        let old_reserve_b = pool.reserve_b;\n\n        // Compute the invariant: k = reserve_a * reserve_b.\n        let k = old_reserve_a * old_reserve_b;\n\n        let new_reserve_a = old_reserve_a + net_in;\n        assert!(new_reserve_a > 0, 201);\n\n        let new_reserve_b = k / new_reserve_a;\n        // The output amount is the reduction in the TokenB reserve.\n        assert!(old_reserve_b > new_reserve_b, 202);\n        let amount_out = old_reserve_b - new_reserve_b;\n\n        // Update the pool's state.\n        pool.reserve_a = new_reserve_a;\n        pool.reserve_b = new_reserve_b;\n        pool.fee_a = pool.fee_a + fee;\n\n        amount_out\n    }\n\n    // swap_b_to_a allows a user to swap TokenB for TokenA.\n    // A fee is deducted from the input amount. The swap uses a constant product pricing formula.\n    // Returns the amount of TokenA output.\n    public fun swap_b_to_a(\n        pool: &mut LiquidityPool,\n        amount_in: u64\n    ): u64 {\n        // Ensure the input amount is positive.\n        assert!(amount_in > 0, 300);\n\n        let fee = amount_in * pool.fee_rate / 100;\n        let net_in = amount_in - fee;\n\n        let old_reserve_b = pool.reserve_b;\n        let old_reserve_a = pool.reserve_a;\n\n        let k = old_reserve_a * old_reserve_b;\n\n        let new_reserve_b = old_reserve_b + net_in;\n        assert!(new_reserve_b > 0, 301);\n\n        let new_reserve_a = k / new_reserve_b;\n        assert!(old_reserve_a > new_reserve_a, 302);\n        let amount_out = old_reserve_a - new_reserve_a;\n\n        // Update the pool's state.\n        pool.reserve_b = new_reserve_b;\n        pool.reserve_a = new_reserve_a;\n        pool.fee_b = pool.fee_b + fee;\n\n        amount_out\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Fee Collection Function\n    ///////////////////////////////////////////////////////////////////////////\n\n    // collect_fees allows the pool admin to withdraw the accumulated fees.\n    // Only the admin (creator) of the pool can invoke this function.\n    public fun collect_fees(\n        pool: &mut LiquidityPool,\n        ctx: &mut TxContext\n    ): (u64, u64) {\n        let caller = sender(ctx);\n        assert!(caller == pool.admin, 400);\n\n        let fees_a = pool.fee_a;\n        let fees_b = pool.fee_b;\n\n        // Reset the fee accumulators.\n        pool.fee_a = 0;\n        pool.fee_b = 0;\n\n        (fees_a, fees_b)\n    }\n}",
      "output": "UPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git\nINCLUDING DEPENDENCY Sui\nINCLUDING DEPENDENCY MoveStdlib\nBUILDING TempContract\nwarning[W02021]: duplicate alias\n  \u250c\u2500 ./sources/temp_contract.move:4:23\n  \u2502\n4 \u2502     use sui::object::{UID, new};\n  \u2502                       ^^^ Unnecessary alias 'UID' for module member 'sui::object::UID'. This alias is provided by default\n  \u2502\n  = This warning can be suppressed with '#[allow(duplicate_alias)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nwarning[W02021]: duplicate alias\n  \u250c\u2500 ./sources/temp_contract.move:5:27\n  \u2502\n5 \u2502     use sui::tx_context::{TxContext, sender};\n  \u2502                           ^^^^^^^^^ Unnecessary alias 'TxContext' for module member 'sui::tx_context::TxContext'. This alias is provided by default\n  \u2502\n  = This warning can be suppressed with '#[allow(duplicate_alias)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nwarning[Lint W04005]: 'abort' or 'assert' without named constant\n   \u250c\u2500 ./sources/temp_contract.move:72:32\n   \u2502\n72 \u2502         assert!(initial_a > 0, 1);\n   \u2502                                ^ Prefer using a named constant.\n   \u2502\n   = Consider using an error constant with the '#[error]' to allow for a more descriptive error.\n   = This warning can be suppressed with '#[allow(lint(abort_without_constant))]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nwarning[Lint W04005]: 'abort' or 'assert' without named constant\n   \u250c\u2500 ./sources/temp_contract.move:73:32\n   \u2502\n73 \u2502         assert!(initial_b > 0, 2);\n   \u2502                                ^ Prefer using a named constant.\n   \u2502\n   = Consider using an error constant with the '#[error]' to allow for a more descriptive error.\n   = This warning can be suppressed with '#[allow(lint(abort_without_constant))]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nwarning[Lint W04005]: 'abort' or 'assert' without named constant\n    \u250c\u2500 ./sources/temp_contract.move:110:77\n    \u2502\n110 \u2502             assert!(amount_a * pool.reserve_b == amount_b * pool.reserve_a, 100);\n    \u2502                                                                             ^^^ Prefer using a named constant.\n    \u2502\n    = Consider using an error constant with the '#[error]' to allow for a more descriptive error.\n    = This warning can be suppressed with '#[allow(lint(abort_without_constant))]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nerror[E06001]: unused value without 'drop'\n    \u250c\u2500 ./sources/temp_contract.move:151:9\n    \u2502\n 53 \u2502     public struct LPToken has key {\n    \u2502                   ------- To satisfy the constraint, the 'drop' ability would need to be added here\n    \u00b7\n138 \u2502         lp: LPToken\n    \u2502         --  ------- The type 'temp_addr::my_module::LPToken' does not have the ability 'drop'\n    \u2502         \u2502    \n    \u2502         The parameter 'lp' still contains a value. The value does not have the 'drop' ability and must be consumed before the function returns\n    \u00b7\n151 \u2502         (amount_a, amount_b)\n    \u2502         ^^^^^^^^^^^^^^^^^^^^ Invalid return\n\nwarning[Lint W04005]: 'abort' or 'assert' without named constant\n    \u250c\u2500 ./sources/temp_contract.move:166:32\n    \u2502\n166 \u2502         assert!(amount_in > 0, 200);\n    \u2502                                ^^^ Prefer using a named constant.\n    \u2502\n    = Consider using an error constant with the '#[error]' to allow for a more descriptive error.\n    = This warning can be suppressed with '#[allow(lint(abort_without_constant))]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nwarning[Lint W04005]: 'abort' or 'assert' without named constant\n    \u250c\u2500 ./sources/temp_contract.move:179:36\n    \u2502\n179 \u2502         assert!(new_reserve_a > 0, 201);\n    \u2502                                    ^^^ Prefer using a named constant.\n    \u2502\n    = Consider using an error constant with the '#[error]' to allow for a more descriptive error.\n    = This warning can be suppressed with '#[allow(lint(abort_without_constant))]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nwarning[Lint W04005]: 'abort' or 'assert' without named constant\n    \u250c\u2500 ./sources/temp_contract.move:183:48\n    \u2502\n183 \u2502         assert!(old_reserve_b > new_reserve_b, 202);\n    \u2502                                                ^^^ Prefer using a named constant.\n    \u2502\n    = Consider using an error constant with the '#[error]' to allow for a more descriptive error.\n    = This warning can be suppressed with '#[allow(lint(abort_without_constant))]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nwarning[Lint W04005]: 'abort' or 'assert' without named constant\n    \u250c\u2500 ./sources/temp_contract.move:202:32\n    \u2502\n202 \u2502         assert!(amount_in > 0, 300);\n    \u2502                                ^^^ Prefer using a named constant.\n    \u2502\n    = Consider using an error constant with the '#[error]' to allow for a more descriptive error.\n    = This warning can be suppressed with '#[allow(lint(abort_without_constant))]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nwarning[Lint W04005]: 'abort' or 'assert' without named constant\n    \u250c\u2500 ./sources/temp_contract.move:213:36\n    \u2502\n213 \u2502         assert!(new_reserve_b > 0, 301);\n    \u2502                                    ^^^ Prefer using a named constant.\n    \u2502\n    = Consider using an error constant with the '#[error]' to allow for a more descriptive error.\n    = This warning can be suppressed with '#[allow(lint(abort_without_constant))]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nwarning[Lint W04005]: 'abort' or 'assert' without named constant\n    \u250c\u2500 ./sources/temp_contract.move:216:48\n    \u2502\n216 \u2502         assert!(old_reserve_a > new_reserve_a, 302);\n    \u2502                                                ^^^ Prefer using a named constant.\n    \u2502\n    = Consider using an error constant with the '#[error]' to allow for a more descriptive error.\n    = This warning can be suppressed with '#[allow(lint(abort_without_constant))]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nwarning[Lint W04005]: 'abort' or 'assert' without named constant\n    \u250c\u2500 ./sources/temp_contract.move:238:39\n    \u2502\n238 \u2502         assert!(caller == pool.admin, 400);\n    \u2502                                       ^^^ Prefer using a named constant.\n    \u2502\n    = Consider using an error constant with the '#[error]' to allow for a more descriptive error.\n    = This warning can be suppressed with '#[allow(lint(abort_without_constant))]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\n",
      "metadata": {
        "iteration": 3,
        "timestamp": 1740791904.767065,
        "error_stats": {
          "errors": 3,
          "compiler_warnings": 2,
          "linter_warnings": 0
        },
        "error_codes": {
          "W21002": {
            "count": 2,
            "message": "duplicate alias",
            "level": "Warning"
          },
          "N01006": {
            "count": 1,
            "message": "unused value without 'drop'",
            "level": "NonblockingError"
          }
        }
      }
    },
    {
      "input": "module temp_addr::my_module {\n\n    // Import necessary functions and types from the Sui framework.\n    use sui::object::{new, UID};\n    use sui::tx_context::{sender, TxContext};\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Error Constants\n    ///////////////////////////////////////////////////////////////////////////\n    const E_INITIAL_A: u64 = 1;\n    const E_INITIAL_B: u64 = 2;\n    const E_LIQUIDITY_RATIO: u64 = 100;\n    const E_SWAP_A_AMOUNT_ZERO: u64 = 200;\n    const E_SWAP_A_NEW_RESERVE_A: u64 = 201;\n    const E_SWAP_A_INVARIANT: u64 = 202;\n    const E_SWAP_B_AMOUNT_ZERO: u64 = 300;\n    const E_SWAP_B_NEW_RESERVE_B: u64 = 301;\n    const E_SWAP_B_INVARIANT: u64 = 302;\n    const E_COLLECT_FEES: u64 = 400;\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Helper Functions\n    ///////////////////////////////////////////////////////////////////////////\n\n    // Returns the minimum of two u64 values.\n    public fun min(a: u64, b: u64): u64 {\n        if (a < b) { \n            a \n        } else { \n            b \n        }\n    }\n\n    // Computes the integer square root of n using Newton's method.\n    public fun sqrt(n: u64): u64 {\n        if (n < 2) {\n            n\n        } else {\n            let mut x = n;\n            let mut y = (x + 1) / 2;\n            while (y < x) {\n                x = y;\n                y = (x + n / x) / 2;\n            };\n            x\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Data Structures\n    ///////////////////////////////////////////////////////////////////////////\n\n    // LiquidityPool stores the state of the pool.\n    // Note: Objects with the 'key' ability must have an 'id: UID' field as the first field.\n    public struct LiquidityPool has key {\n        id: UID,\n        reserve_a: u64,\n        reserve_b: u64,\n        fee_rate: u64,     // Fee rate as a percentage (e.g., 1 means 1% fee)\n        fee_a: u64,        // Accumulated fees for TokenA from swaps\n        fee_b: u64,        // Accumulated fees for TokenB from swaps\n        total_shares: u64, // Total liquidity shares issued\n        admin: address     // Admin address allowed to collect fees\n    }\n\n    // LPToken represents the liquidity provider's share in the pool.\n    // Added the drop ability so that the token can be consumed.\n    public struct LPToken has key, drop {\n        id: UID,\n        share: u64\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Initialization Functions\n    ///////////////////////////////////////////////////////////////////////////\n\n    // create_pool initializes a new liquidity pool.\n    // The creator provides the initial amounts for TokenA and TokenB and the fee rate.\n    // The initial liquidity shares are computed as the square root of (initial_a * initial_b).\n    public fun create_pool(\n        ctx: &mut TxContext,\n        initial_a: u64,\n        initial_b: u64,\n        fee_rate: u64\n    ): (LiquidityPool, LPToken) {\n        // Ensure that initial liquidity amounts are positive.\n        assert!(initial_a > 0, E_INITIAL_A);\n        assert!(initial_b > 0, E_INITIAL_B);\n        let initial_shares = sqrt(initial_a * initial_b);\n\n        let pool = LiquidityPool {\n            id: new(ctx),\n            reserve_a: initial_a,\n            reserve_b: initial_b,\n            fee_rate: fee_rate,\n            fee_a: 0,\n            fee_b: 0,\n            total_shares: initial_shares,\n            admin: sender(ctx)\n        };\n\n        let lp_token = LPToken {\n            id: new(ctx),\n            share: initial_shares\n        };\n\n        (pool, lp_token)\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Liquidity Management Functions\n    ///////////////////////////////////////////////////////////////////////////\n\n    // add_liquidity allows liquidity providers to deposit additional funds into the pool.\n    // Liquidity must be provided in the same ratio as the current reserves.\n    // Returns an LPToken representing the provider's share.\n    public fun add_liquidity(\n        ctx: &mut TxContext,\n        pool: &mut LiquidityPool,\n        amount_a: u64,\n        amount_b: u64\n    ): LPToken {\n        // If the pool already has liquidity, enforce the ratio equality via cross multiplication.\n        if (pool.reserve_a != 0 && pool.reserve_b != 0) {\n            assert!(amount_a * pool.reserve_b == amount_b * pool.reserve_a, E_LIQUIDITY_RATIO);\n        };\n\n        let share: u64 = if (pool.total_shares == 0) {\n            sqrt(amount_a * amount_b)\n        } else {\n            let share_a = amount_a * pool.total_shares / pool.reserve_a;\n            let share_b = amount_b * pool.total_shares / pool.reserve_b;\n            min(share_a, share_b)\n        };\n\n        // Update the pool's state.\n        pool.reserve_a = pool.reserve_a + amount_a;\n        pool.reserve_b = pool.reserve_b + amount_b;\n        pool.total_shares = pool.total_shares + share;\n\n        let lp_token = LPToken {\n            id: new(ctx),\n            share: share\n        };\n\n        lp_token\n    }\n\n    // remove_liquidity allows liquidity providers to withdraw their share from the pool.\n    // The provider supplies an LPToken and receives amounts of TokenA and TokenB proportionally.\n    public fun remove_liquidity(\n        pool: &mut LiquidityPool,\n        lp: LPToken\n    ): (u64, u64) {\n        // Destructure LPToken to consume it.\n        let LPToken { share, .. } = lp;\n        // Calculate the amounts to withdraw based on the provider's share.\n        let amount_a = share * pool.reserve_a / pool.total_shares;\n        let amount_b = share * pool.reserve_b / pool.total_shares;\n\n        // Update the pool state.\n        pool.reserve_a = pool.reserve_a - amount_a;\n        pool.reserve_b = pool.reserve_b - amount_b;\n        pool.total_shares = pool.total_shares - share;\n\n        (amount_a, amount_b)\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Swap Functions\n    ///////////////////////////////////////////////////////////////////////////\n\n    // swap_a_to_b allows a user to swap TokenA for TokenB.\n    // A fee is deducted from the input amount. The swap uses a constant product pricing formula.\n    // Returns the amount of TokenB output.\n    public fun swap_a_to_b(\n        pool: &mut LiquidityPool,\n        amount_in: u64\n    ): u64 {\n        // Ensure the input amount is positive.\n        assert!(amount_in > 0, E_SWAP_A_AMOUNT_ZERO);\n\n        // Calculate fee and net input.\n        let fee = amount_in * pool.fee_rate / 100;\n        let net_in = amount_in - fee;\n\n        let old_reserve_a = pool.reserve_a;\n        let old_reserve_b = pool.reserve_b;\n\n        // Compute the invariant: k = reserve_a * reserve_b.\n        let k = old_reserve_a * old_reserve_b;\n\n        let new_reserve_a = old_reserve_a + net_in;\n        assert!(new_reserve_a > 0, E_SWAP_A_NEW_RESERVE_A);\n\n        let new_reserve_b = k / new_reserve_a;\n        // The output amount is the reduction in the TokenB reserve.\n        assert!(old_reserve_b > new_reserve_b, E_SWAP_A_INVARIANT);\n        let amount_out = old_reserve_b - new_reserve_b;\n\n        // Update the pool's state.\n        pool.reserve_a = new_reserve_a;\n        pool.reserve_b = new_reserve_b;\n        pool.fee_a = pool.fee_a + fee;\n\n        amount_out\n    }\n\n    // swap_b_to_a allows a user to swap TokenB for TokenA.\n    // A fee is deducted from the input amount. The swap uses a constant product pricing formula.\n    // Returns the amount of TokenA output.\n    public fun swap_b_to_a(\n        pool: &mut LiquidityPool,\n        amount_in: u64\n    ): u64 {\n        // Ensure the input amount is positive.\n        assert!(amount_in > 0, E_SWAP_B_AMOUNT_ZERO);\n\n        let fee = amount_in * pool.fee_rate / 100;\n        let net_in = amount_in - fee;\n\n        let old_reserve_b = pool.reserve_b;\n        let old_reserve_a = pool.reserve_a;\n\n        let k = old_reserve_a * old_reserve_b;\n\n        let new_reserve_b = old_reserve_b + net_in;\n        assert!(new_reserve_b > 0, E_SWAP_B_NEW_RESERVE_B);\n\n        let new_reserve_a = k / new_reserve_b;\n        assert!(old_reserve_a > new_reserve_a, E_SWAP_B_INVARIANT);\n        let amount_out = old_reserve_a - new_reserve_a;\n\n        // Update the pool's state.\n        pool.reserve_b = new_reserve_b;\n        pool.reserve_a = new_reserve_a;\n        pool.fee_b = pool.fee_b + fee;\n\n        amount_out\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Fee Collection Function\n    ///////////////////////////////////////////////////////////////////////////\n\n    // collect_fees allows the pool admin to withdraw the accumulated fees.\n    // Only the admin (creator) of the pool can invoke this function.\n    public fun collect_fees(\n        pool: &mut LiquidityPool,\n        ctx: &mut TxContext\n    ): (u64, u64) {\n        let caller = sender(ctx);\n        assert!(caller == pool.admin, E_COLLECT_FEES);\n\n        let fees_a = pool.fee_a;\n        let fees_b = pool.fee_b;\n\n        // Reset the fee accumulators.\n        pool.fee_a = 0;\n        pool.fee_b = 0;\n\n        (fees_a, fees_b)\n    }\n}",
      "output": "UPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git\nINCLUDING DEPENDENCY Sui\nINCLUDING DEPENDENCY MoveStdlib\nBUILDING TempContract\nwarning[W02021]: duplicate alias\n  \u250c\u2500 ./sources/temp_contract.move:4:28\n  \u2502\n4 \u2502     use sui::object::{new, UID};\n  \u2502                            ^^^ Unnecessary alias 'UID' for module member 'sui::object::UID'. This alias is provided by default\n  \u2502\n  = This warning can be suppressed with '#[allow(duplicate_alias)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nwarning[W02021]: duplicate alias\n  \u250c\u2500 ./sources/temp_contract.move:5:35\n  \u2502\n5 \u2502     use sui::tx_context::{sender, TxContext};\n  \u2502                                   ^^^^^^^^^ Unnecessary alias 'TxContext' for module member 'sui::tx_context::TxContext'. This alias is provided by default\n  \u2502\n  = This warning can be suppressed with '#[allow(duplicate_alias)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nerror[E05001]: ability constraint not satisfied\n   \u250c\u2500 ./sources/temp_contract.move:69:13\n   \u2502\n69 \u2502         id: UID,\n   \u2502             ^^^\n   \u2502             \u2502\n   \u2502             Invalid field type. The struct was declared with the ability 'drop' so all fields require the ability 'drop'\n   \u2502             The type 'sui::object::UID' does not have the ability 'drop'\n   \u2502\n   \u250c\u2500 /Users/kz/.move/https___github_com_MystenLabs_sui_git_framework__testnet/crates/sui-framework/packages/sui-framework/sources/object.move:69:15\n   \u2502\n69 \u2502 public struct UID has store {\n   \u2502               --- To satisfy the constraint, the 'drop' ability would need to be added here\n\nerror[E05001]: ability constraint not satisfied\n    \u250c\u2500 ./sources/temp_contract.move:156:30\n    \u2502\n 69 \u2502         id: UID,\n    \u2502             --- The type 'sui::object::UID' does not have the ability 'drop'\n    \u00b7\n156 \u2502         let LPToken { share, .. } = lp;\n    \u2502                              ^^ Cannot ignore values without the 'drop' ability. The value must be used\n    \u2502\n    \u250c\u2500 /Users/kz/.move/https___github_com_MystenLabs_sui_git_framework__testnet/crates/sui-framework/packages/sui-framework/sources/object.move:69:15\n    \u2502\n 69 \u2502 public struct UID has store {\n    \u2502               --- To satisfy the constraint, the 'drop' ability would need to be added here\n\n",
      "metadata": {
        "iteration": 4,
        "timestamp": 1740791926.516456,
        "error_stats": {
          "errors": 4,
          "compiler_warnings": 2,
          "linter_warnings": 0
        },
        "error_codes": {
          "W21002": {
            "count": 2,
            "message": "duplicate alias",
            "level": "Warning"
          },
          "N01005": {
            "count": 2,
            "message": "ability constraint not satisfied",
            "level": "NonblockingError"
          }
        }
      }
    },
    {
      "input": "module temp_addr::my_module {\n\n    // Import necessary functions and types from the Sui framework.\n    use sui::object::{new, UID};\n    use sui::tx_context::{sender, TxContext};\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Error Constants\n    ///////////////////////////////////////////////////////////////////////////\n    const E_INITIAL_A: u64 = 1;\n    const E_INITIAL_B: u64 = 2;\n    const E_LIQUIDITY_RATIO: u64 = 100;\n    const E_SWAP_A_AMOUNT_ZERO: u64 = 200;\n    const E_SWAP_A_NEW_RESERVE_A: u64 = 201;\n    const E_SWAP_A_INVARIANT: u64 = 202;\n    const E_SWAP_B_AMOUNT_ZERO: u64 = 300;\n    const E_SWAP_B_NEW_RESERVE_B: u64 = 301;\n    const E_SWAP_B_INVARIANT: u64 = 302;\n    const E_COLLECT_FEES: u64 = 400;\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Helper Functions\n    ///////////////////////////////////////////////////////////////////////////\n\n    // Returns the minimum of two u64 values.\n    public fun min(a: u64, b: u64): u64 {\n        if (a < b) {\n            a\n        } else {\n            b\n        }\n    }\n\n    // Computes the integer square root of n using Newton's method.\n    public fun sqrt(n: u64): u64 {\n        if (n < 2) {\n            n\n        } else {\n            let mut x = n;\n            let mut y = (x + 1) / 2;\n            while (y < x) {\n                x = y;\n                y = (x + n / x) / 2;\n            };\n            x\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Data Structures\n    ///////////////////////////////////////////////////////////////////////////\n\n    // LiquidityPool stores the state of the pool.\n    // Note: Objects with the 'key' ability must have an 'id: UID' field as the first field.\n    public struct LiquidityPool has key {\n        id: UID,\n        reserve_a: u64,\n        reserve_b: u64,\n        fee_rate: u64,     // Fee rate as a percentage (e.g., 1 means 1% fee)\n        fee_a: u64,        // Accumulated fees for TokenA from swaps\n        fee_b: u64,        // Accumulated fees for TokenB from swaps\n        total_shares: u64, // Total liquidity shares issued\n        admin: address     // Admin address allowed to collect fees\n    }\n\n    // LPToken represents the liquidity provider's share in the pool.\n    // Note: We do not add the drop ability because UID does not support drop.\n    public struct LPToken has key {\n        id: UID,\n        share: u64\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Initialization Functions\n    ///////////////////////////////////////////////////////////////////////////\n\n    // create_pool initializes a new liquidity pool.\n    // The creator provides the initial amounts for TokenA and TokenB and the fee rate.\n    // The initial liquidity shares are computed as the square root of (initial_a * initial_b).\n    public fun create_pool(\n        ctx: &mut TxContext,\n        initial_a: u64,\n        initial_b: u64,\n        fee_rate: u64\n    ): (LiquidityPool, LPToken) {\n        // Ensure that initial liquidity amounts are positive.\n        assert!(initial_a > 0, E_INITIAL_A);\n        assert!(initial_b > 0, E_INITIAL_B);\n        let initial_shares = sqrt(initial_a * initial_b);\n\n        let pool = LiquidityPool {\n            id: new(ctx),\n            reserve_a: initial_a,\n            reserve_b: initial_b,\n            fee_rate: fee_rate,\n            fee_a: 0,\n            fee_b: 0,\n            total_shares: initial_shares,\n            admin: sender(ctx)\n        };\n\n        let lp_token = LPToken {\n            id: new(ctx),\n            share: initial_shares\n        };\n\n        (pool, lp_token)\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Liquidity Management Functions\n    ///////////////////////////////////////////////////////////////////////////\n\n    // add_liquidity allows liquidity providers to deposit additional funds into the pool.\n    // Liquidity must be provided in the same ratio as the current reserves.\n    // Returns an LPToken representing the provider's share.\n    public fun add_liquidity(\n        ctx: &mut TxContext,\n        pool: &mut LiquidityPool,\n        amount_a: u64,\n        amount_b: u64\n    ): LPToken {\n        // If the pool already has liquidity, enforce the ratio equality via cross multiplication.\n        if (pool.reserve_a != 0 && pool.reserve_b != 0) {\n            assert!(amount_a * pool.reserve_b == amount_b * pool.reserve_a, E_LIQUIDITY_RATIO);\n        };\n\n        let share: u64 = if (pool.total_shares == 0) {\n            sqrt(amount_a * amount_b)\n        } else {\n            let share_a = amount_a * pool.total_shares / pool.reserve_a;\n            let share_b = amount_b * pool.total_shares / pool.reserve_b;\n            min(share_a, share_b)\n        };\n\n        // Update the pool's state.\n        pool.reserve_a = pool.reserve_a + amount_a;\n        pool.reserve_b = pool.reserve_b + amount_b;\n        pool.total_shares = pool.total_shares + share;\n\n        let lp_token = LPToken {\n            id: new(ctx),\n            share: share\n        };\n\n        lp_token\n    }\n\n    // remove_liquidity allows liquidity providers to withdraw their share from the pool.\n    // The provider supplies an LPToken and receives amounts of TokenA and TokenB proportionally.\n    public fun remove_liquidity(\n        pool: &mut LiquidityPool,\n        lp: LPToken\n    ): (u64, u64) {\n        // Destructure LPToken completely to consume it.\n        let LPToken { share, id: _dummy } = lp;\n        // Calculate the amounts to withdraw based on the provider's share.\n        let amount_a = share * pool.reserve_a / pool.total_shares;\n        let amount_b = share * pool.reserve_b / pool.total_shares;\n\n        // Update the pool state.\n        pool.reserve_a = pool.reserve_a - amount_a;\n        pool.reserve_b = pool.reserve_b - amount_b;\n        pool.total_shares = pool.total_shares - share;\n\n        (amount_a, amount_b)\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Swap Functions\n    ///////////////////////////////////////////////////////////////////////////\n\n    // swap_a_to_b allows a user to swap TokenA for TokenB.\n    // A fee is deducted from the input amount. The swap uses a constant product pricing formula.\n    // Returns the amount of TokenB output.\n    public fun swap_a_to_b(\n        pool: &mut LiquidityPool,\n        amount_in: u64\n    ): u64 {\n        // Ensure the input amount is positive.\n        assert!(amount_in > 0, E_SWAP_A_AMOUNT_ZERO);\n\n        // Calculate fee and net input.\n        let fee = amount_in * pool.fee_rate / 100;\n        let net_in = amount_in - fee;\n\n        let old_reserve_a = pool.reserve_a;\n        let old_reserve_b = pool.reserve_b;\n\n        // Compute the invariant: k = reserve_a * reserve_b.\n        let k = old_reserve_a * old_reserve_b;\n\n        let new_reserve_a = old_reserve_a + net_in;\n        assert!(new_reserve_a > 0, E_SWAP_A_NEW_RESERVE_A);\n\n        let new_reserve_b = k / new_reserve_a;\n        // The output amount is the reduction in the TokenB reserve.\n        assert!(old_reserve_b > new_reserve_b, E_SWAP_A_INVARIANT);\n        let amount_out = old_reserve_b - new_reserve_b;\n\n        // Update the pool's state.\n        pool.reserve_a = new_reserve_a;\n        pool.reserve_b = new_reserve_b;\n        pool.fee_a = pool.fee_a + fee;\n\n        amount_out\n    }\n\n    // swap_b_to_a allows a user to swap TokenB for TokenA.\n    // A fee is deducted from the input amount. The swap uses a constant product pricing formula.\n    // Returns the amount of TokenA output.\n    public fun swap_b_to_a(\n        pool: &mut LiquidityPool,\n        amount_in: u64\n    ): u64 {\n        // Ensure the input amount is positive.\n        assert!(amount_in > 0, E_SWAP_B_AMOUNT_ZERO);\n\n        let fee = amount_in * pool.fee_rate / 100;\n        let net_in = amount_in - fee;\n\n        let old_reserve_b = pool.reserve_b;\n        let old_reserve_a = pool.reserve_a;\n\n        let k = old_reserve_a * old_reserve_b;\n\n        let new_reserve_b = old_reserve_b + net_in;\n        assert!(new_reserve_b > 0, E_SWAP_B_NEW_RESERVE_B);\n\n        let new_reserve_a = k / new_reserve_b;\n        assert!(old_reserve_a > new_reserve_a, E_SWAP_B_INVARIANT);\n        let amount_out = old_reserve_a - new_reserve_a;\n\n        // Update the pool's state.\n        pool.reserve_b = new_reserve_b;\n        pool.reserve_a = new_reserve_a;\n        pool.fee_b = pool.fee_b + fee;\n\n        amount_out\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Fee Collection Function\n    ///////////////////////////////////////////////////////////////////////////\n\n    // collect_fees allows the pool admin to withdraw the accumulated fees.\n    // Only the admin (creator) of the pool can invoke this function.\n    public fun collect_fees(\n        pool: &mut LiquidityPool,\n        ctx: &mut TxContext\n    ): (u64, u64) {\n        let caller = sender(ctx);\n        assert!(caller == pool.admin, E_COLLECT_FEES);\n\n        let fees_a = pool.fee_a;\n        let fees_b = pool.fee_b;\n\n        // Reset the fee accumulators.\n        pool.fee_a = 0;\n        pool.fee_b = 0;\n\n        (fees_a, fees_b)\n    }\n}",
      "output": "UPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git\nINCLUDING DEPENDENCY Sui\nINCLUDING DEPENDENCY MoveStdlib\nBUILDING TempContract\nwarning[W02021]: duplicate alias\n  \u250c\u2500 ./sources/temp_contract.move:4:28\n  \u2502\n4 \u2502     use sui::object::{new, UID};\n  \u2502                            ^^^ Unnecessary alias 'UID' for module member 'sui::object::UID'. This alias is provided by default\n  \u2502\n  = This warning can be suppressed with '#[allow(duplicate_alias)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nwarning[W02021]: duplicate alias\n  \u250c\u2500 ./sources/temp_contract.move:5:35\n  \u2502\n5 \u2502     use sui::tx_context::{sender, TxContext};\n  \u2502                                   ^^^^^^^^^ Unnecessary alias 'TxContext' for module member 'sui::tx_context::TxContext'. This alias is provided by default\n  \u2502\n  = This warning can be suppressed with '#[allow(duplicate_alias)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nerror[E06001]: unused value without 'drop'\n    \u250c\u2500 ./sources/temp_contract.move:166:9\n    \u2502\n 69 \u2502         id: UID,\n    \u2502             --- The type 'sui::object::UID' does not have the ability 'drop'\n    \u00b7\n156 \u2502         let LPToken { share, id: _dummy } = lp;\n    \u2502                                  ------ The local variable '_dummy' still contains a value. The value does not have the 'drop' ability and must be consumed before the function returns\n    \u00b7\n166 \u2502         (amount_a, amount_b)\n    \u2502         ^^^^^^^^^^^^^^^^^^^^ Invalid return\n    \u2502\n    \u250c\u2500 /Users/kz/.move/https___github_com_MystenLabs_sui_git_framework__testnet/crates/sui-framework/packages/sui-framework/sources/object.move:69:15\n    \u2502\n 69 \u2502 public struct UID has store {\n    \u2502               --- To satisfy the constraint, the 'drop' ability would need to be added here\n\n",
      "metadata": {
        "iteration": 5,
        "timestamp": 1740791954.788831,
        "error_stats": {
          "errors": 3,
          "compiler_warnings": 2,
          "linter_warnings": 0
        },
        "error_codes": {
          "W21002": {
            "count": 2,
            "message": "duplicate alias",
            "level": "Warning"
          },
          "N01006": {
            "count": 1,
            "message": "unused value without 'drop'",
            "level": "NonblockingError"
          }
        }
      }
    }
  ],
  "error_histogram": {
    "E02003": [
      1,
      0,
      0,
      0,
      0
    ],
    "N02001": [
      5,
      2,
      0,
      0,
      0
    ],
    "N03001": [
      2,
      2,
      0,
      0,
      0
    ],
    "W06009": [
      4,
      4,
      0,
      0,
      0
    ],
    "N07002": [
      2,
      0,
      0,
      0,
      0
    ],
    "W02009": [
      2,
      0,
      0,
      0,
      0
    ],
    "E06003": [
      2,
      5,
      0,
      0,
      0
    ],
    "W21002": [
      0,
      2,
      2,
      2,
      2
    ],
    "W07010": [
      0,
      1,
      0,
      0,
      0
    ],
    "N01006": [
      0,
      0,
      1,
      0,
      1
    ],
    "N01005": [
      0,
      0,
      0,
      2,
      0
    ]
  },
  "iterations_data": [
    {
      "iteration": 1,
      "total_errors": 18,
      "error_breakdown": {
        "E02003": {
          "count": 1,
          "message": "unbound module",
          "level": "BlockingError"
        },
        "N02001": {
          "count": 5,
          "message": "unexpected token",
          "level": "NonblockingError"
        },
        "N03001": {
          "count": 2,
          "message": "invalid modifier",
          "level": "NonblockingError"
        },
        "W06009": {
          "count": 4,
          "message": "unused struct type parameter",
          "level": "Warning"
        },
        "N07002": {
          "count": 2,
          "message": "invalid object declaration",
          "level": "NonblockingError"
        },
        "W02009": {
          "count": 2,
          "message": "unused variable",
          "level": "Warning"
        },
        "E06003": {
          "count": 2,
          "message": "unexpected name in this position",
          "level": "BlockingError"
        }
      }
    },
    {
      "iteration": 2,
      "total_errors": 16,
      "error_breakdown": {
        "W21002": {
          "count": 2,
          "message": "duplicate alias",
          "level": "Warning"
        },
        "W07010": {
          "count": 1,
          "message": "issue with attribute value",
          "level": "Warning"
        },
        "N02001": {
          "count": 2,
          "message": "unexpected token",
          "level": "NonblockingError"
        },
        "N03001": {
          "count": 2,
          "message": "invalid modifier",
          "level": "NonblockingError"
        },
        "W06009": {
          "count": 4,
          "message": "unused struct type parameter",
          "level": "Warning"
        },
        "E06003": {
          "count": 5,
          "message": "unexpected name in this position",
          "level": "BlockingError"
        }
      }
    },
    {
      "iteration": 3,
      "total_errors": 3,
      "error_breakdown": {
        "W21002": {
          "count": 2,
          "message": "duplicate alias",
          "level": "Warning"
        },
        "N01006": {
          "count": 1,
          "message": "unused value without 'drop'",
          "level": "NonblockingError"
        }
      }
    },
    {
      "iteration": 4,
      "total_errors": 4,
      "error_breakdown": {
        "W21002": {
          "count": 2,
          "message": "duplicate alias",
          "level": "Warning"
        },
        "N01005": {
          "count": 2,
          "message": "ability constraint not satisfied",
          "level": "NonblockingError"
        }
      }
    },
    {
      "iteration": 5,
      "total_errors": 3,
      "error_breakdown": {
        "W21002": {
          "count": 2,
          "message": "duplicate alias",
          "level": "Warning"
        },
        "N01006": {
          "count": 1,
          "message": "unused value without 'drop'",
          "level": "NonblockingError"
        }
      }
    }
  ],
  "total_iterations": 5
}