{
  "version": "1.0",
  "created_at": "2025-02-28T16:48:36.870530",
  "description": "Sui Move compiler error prediction dataset",
  "examples": [
    {
      "input": "module 0x0::my_module {\n\n    use std::vector;\n    use std::signer;\n    use sui::coin::{Coin, destroy, value, create};\n\n    /// Error codes used in the module.\n    const E_LOCKED: u64 = 1;\n    const E_UNAUTHORIZED: u64 = 2;\n\n    /// A resource that represents the global staking pool.\n    ///\n    /// This pool aggregates staked SUI, mints liquid staking tokens,\n    /// and manages reward accrual and delegation to validators.\n    struct StakingPool has key {\n        /// The admin address that controls certain privileged operations.\n        admin: address,\n        /// Total amount of SUI staked in the pool.\n        total_staked: u64,\n        /// Total supply of liquid staking tokens outstanding.\n        total_liquid_tokens: u64,\n        /// Accumulated rewards available for distribution.\n        pending_rewards: u64,\n        /// A vector tracking delegation amounts to validators.\n        /// Each item is a tuple (validator_address, delegated_amount).\n        validator_delegations: vector<(address, u64)>,\n    }\n\n    /// A resource representing a user's deposit ticket.\n    ///\n    /// This ticket is issued when a user stakes SUI and represents\n    /// their position in the pool with associated liquid tokens.\n    /// A non-zero lock_until value indicates that the deposit is locked\n    /// until the specified unix timestamp.\n    struct LiquidTicket has key, store {\n        owner: address,\n        liquid_amount: u64,\n        lock_until: u64,\n    }\n\n    ///////////////////////////\n    // Module Initialization //\n    ///////////////////////////\n\n    /// Initializes the staking pool.\n    ///\n    /// The caller becomes the admin and owner of the StakingPool resource.\n    public fun initialize(admin: &signer) {\n        let pool = StakingPool {\n            admin: signer::address_of(admin),\n            total_staked: 0,\n            total_liquid_tokens: 0,\n            pending_rewards: 0,\n            validator_delegations: vector::empty(),\n        };\n        move_to(admin, pool);\n    }\n\n    //////////////////////\n    // User Interfaces  //\n    //////////////////////\n\n    /// Stake SUI into the pool.\n    ///\n    /// Accepts a Coin<SUI> (native SUI coin) from the user, mints liquid staking tokens\n    /// represented by a LiquidTicket, and updates the staking pool state.\n    /// The user can optionally specify a lock period via a unix timestamp (lock_until).\n    /// The chosen validator for delegation is also recorded.\n    public fun stake(\n        pool_addr: address,\n        user: &signer,\n        sui_coin: Coin,\n        lock_until: u64,\n        validator: address\n    ): LiquidTicket {\n        // Borrow the staking pool resource published at pool_addr.\n        let pool_ref = borrow_global_mut<StakingPool>(pool_addr);\n\n        // Retrieve the coin value.\n        let amount = value(&sui_coin);\n\n        // Determine the number of liquid tokens to mint.\n        // If the pool is empty, mint tokens at a 1:1 ratio.\n        // Otherwise, mint tokens proportional to the user's contribution.\n        let minted_liquid: u64;\n        if (pool_ref.total_staked == 0) {\n            minted_liquid = amount;\n        } else {\n            minted_liquid = amount * pool_ref.total_liquid_tokens / pool_ref.total_staked;\n        }\n\n        // Update pool totals.\n        pool_ref.total_staked = pool_ref.total_staked + amount;\n        pool_ref.total_liquid_tokens = pool_ref.total_liquid_tokens + minted_liquid;\n\n        // Update validator delegation.\n        let idx = index_of_validator(&pool_ref.validator_delegations, validator);\n        if (idx < vector::length(&pool_ref.validator_delegations)) {\n            let (val, delegated_amount) = *vector::borrow_mut(&mut pool_ref.validator_delegations, idx);\n            vector::borrow_mut(&mut pool_ref.validator_delegations, idx).1 = delegated_amount + amount;\n        } else {\n            vector::push_back(&mut pool_ref.validator_delegations, (validator, amount));\n        }\n\n        // Destroy the SUI coin as it is now added to the pool.\n        destroy(sui_coin);\n\n        // Mint a LiquidTicket representing the user's staked position.\n        let ticket = LiquidTicket {\n            owner: signer::address_of(user),\n            liquid_amount: minted_liquid,\n            lock_until: lock_until,\n        };\n\n        ticket\n    }\n\n    /// Unstake SUI from the pool.\n    ///\n    /// Consumes the user's LiquidTicket and returns a Coin<SUI> representing the\n    /// underlying staked amount plus rewards. Enforces any lock period specified during staking.\n    public fun unstake(\n        pool_addr: address,\n        ticket: LiquidTicket,\n        current_time: u64\n    ): Coin {\n        // Ensure the deposit is unlocked.\n        if (ticket.lock_until > current_time) {\n            abort E_LOCKED;\n        }\n\n        let pool_ref = borrow_global_mut<StakingPool>(pool_addr);\n\n        // Calculate total pool value including rewards.\n        let total_value = pool_ref.total_staked + pool_ref.pending_rewards;\n\n        // User's share is proportional to their liquid token holdings.\n        let user_value = ticket.liquid_amount * total_value / pool_ref.total_liquid_tokens;\n\n        // Update pool totals proportionally.\n        let staked_reduction = ticket.liquid_amount * pool_ref.total_staked / pool_ref.total_liquid_tokens;\n        let rewards_reduction = ticket.liquid_amount * pool_ref.pending_rewards / pool_ref.total_liquid_tokens;\n        pool_ref.total_staked = pool_ref.total_staked - staked_reduction;\n        pool_ref.pending_rewards = pool_ref.pending_rewards - rewards_reduction;\n        pool_ref.total_liquid_tokens = pool_ref.total_liquid_tokens - ticket.liquid_amount;\n\n        // Return a Coin<SUI> representing the unstaked value.\n        let unstaked_coin = create(user_value);\n\n        // The LiquidTicket resource is consumed (dropped) here.\n        unstaked_coin\n    }\n\n    //////////////////////\n    // Admin Interfaces //\n    //////////////////////\n\n    /// Deposit rewards into the staking pool.\n    ///\n    /// Only the admin can call this function.\n    /// Rewards are added to the pool's pending_rewards for distribution.\n    public fun deposit_rewards(\n        pool_addr: address,\n        admin: &signer,\n        rewards: Coin\n    ) {\n        let pool_ref = borrow_global_mut<StakingPool>(pool_addr);\n        if (signer::address_of(admin) != pool_ref.admin) {\n            abort E_UNAUTHORIZED;\n        };\n        let reward_amount = value(&rewards);\n        pool_ref.pending_rewards = pool_ref.pending_rewards + reward_amount;\n        destroy(rewards);\n    }\n\n    /// Delegate additional SUI to a validator.\n    ///\n    /// Only the admin can modify the delegation allocations.\n    public fun delegate(\n        pool_addr: address,\n        admin: &signer,\n        validator: address,\n        amount: u64\n    ) {\n        let pool_ref = borrow_global_mut<StakingPool>(pool_addr);\n        if (signer::address_of(admin) != pool_ref.admin) {\n            abort E_UNAUTHORIZED;\n        };\n        let idx = index_of_validator(&pool_ref.validator_delegations, validator);\n        if (idx < vector::length(&pool_ref.validator_delegations)) {\n            let (val, delegated_amount) = *vector::borrow_mut(&mut pool_ref.validator_delegations, idx);\n            vector::borrow_mut(&mut pool_ref.validator_delegations, idx).1 = delegated_amount + amount;\n        } else {\n            vector::push_back(&mut pool_ref.validator_delegations, (validator, amount));\n        }\n    }\n\n    ///////////////////////////\n    // Internal Helper Funcs //\n    ///////////////////////////\n\n    /// Returns the index of the validator in the delegation vector.\n    /// If the validator is not found, returns the length of the vector.\n    fun index_of_validator(delegations: &vector<(address, u64)>, validator: address): u64 {\n        let len = vector::length(delegations);\n        let mut i = 0;\n        while (i < len) {\n            let (val, _) = *vector::borrow(delegations, i);\n            if (val == validator) {\n                return i;\n            };\n            i = i + 1;\n        };\n        i\n    }\n}",
      "output": "UPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git\nINCLUDING DEPENDENCY Sui\nINCLUDING DEPENDENCY MoveStdlib\nBUILDING TempContract\nwarning[W02021]: duplicate alias\n  \u250c\u2500 ./sources/temp_contract.move:3:14\n  \u2502\n3 \u2502     use std::vector;\n  \u2502              ^^^^^^ Unnecessary alias 'vector' for module 'std::vector'. This alias is provided by default\n  \u2502\n  = This warning can be suppressed with '#[allow(duplicate_alias)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nerror[E03002]: unbound module\n  \u250c\u2500 ./sources/temp_contract.move:4:9\n  \u2502\n4 \u2502     use std::signer;\n  \u2502         ^^^^^^^^^^^ Invalid 'use'. Unbound module: 'std::signer'\n\nerror[E03003]: unbound module member\n  \u250c\u2500 ./sources/temp_contract.move:5:27\n  \u2502\n5 \u2502     use sui::coin::{Coin, destroy, value, create};\n  \u2502                           ^^^^^^^ Invalid 'use'. Unbound member 'destroy' in module 'sui::coin'\n  \u2502\n  \u250c\u2500 /Users/kz/.move/https___github_com_MystenLabs_sui_git_framework__testnet/crates/sui-framework/packages/sui-framework/sources/coin.move:7:13\n  \u2502\n7 \u2502 module sui::coin;\n  \u2502             ---- Module 'sui::coin' declared here\n\nerror[E03003]: unbound module member\n  \u250c\u2500 ./sources/temp_contract.move:5:43\n  \u2502\n5 \u2502     use sui::coin::{Coin, destroy, value, create};\n  \u2502                                           ^^^^^^ Invalid 'use'. Unbound member 'create' in module 'sui::coin'\n  \u2502\n  \u250c\u2500 /Users/kz/.move/https___github_com_MystenLabs_sui_git_framework__testnet/crates/sui-framework/packages/sui-framework/sources/coin.move:7:13\n  \u2502\n7 \u2502 module sui::coin;\n  \u2502             ---- Module 'sui::coin' declared here\n\nerror[E01003]: invalid modifier\n   \u250c\u2500 ./sources/temp_contract.move:15:5\n   \u2502\n15 \u2502     struct StakingPool has key {\n   \u2502     ^^^^^^ Invalid struct declaration. Internal struct declarations are not yet supported\n   \u2502\n   = Visibility annotations are required on struct declarations from the Move 2024 edition onwards.\n\nerror[Sui E02007]: invalid object declaration\n   \u250c\u2500 ./sources/temp_contract.move:17:9\n   \u2502\n15 \u2502     struct StakingPool has key {\n   \u2502                            --- The 'key' ability is used to declare objects in Sui\n16 \u2502         /// The admin address that controls certain privileged operations.\n17 \u2502         admin: address,\n   \u2502         ^^^^^ Invalid object 'StakingPool'. Structs with the 'key' ability must have 'id: sui::object::UID' as their first field\n\nerror[E04004]: expected a single non-reference type\n   \u250c\u2500 ./sources/temp_contract.move:26:32\n   \u2502\n26 \u2502         validator_delegations: vector<(address, u64)>,\n   \u2502                                ^^^^^^^^^^^^^^^^^^^^^^\n   \u2502                                \u2502      \u2502\n   \u2502                                \u2502      Expected a single non-reference type, but found: '(address, u64)'\n   \u2502                                Invalid type argument\n\nerror[E01003]: invalid modifier\n   \u250c\u2500 ./sources/temp_contract.move:35:5\n   \u2502\n35 \u2502     struct LiquidTicket has key, store {\n   \u2502     ^^^^^^ Invalid struct declaration. Internal struct declarations are not yet supported\n   \u2502\n   = Visibility annotations are required on struct declarations from the Move 2024 edition onwards.\n\nerror[Sui E02007]: invalid object declaration\n   \u250c\u2500 ./sources/temp_contract.move:36:9\n   \u2502\n35 \u2502     struct LiquidTicket has key, store {\n   \u2502                             --- The 'key' ability is used to declare objects in Sui\n36 \u2502         owner: address,\n   \u2502         ^^^^^ Invalid object 'LiquidTicket'. Structs with the 'key' ability must have 'id: sui::object::UID' as their first field\n\nerror[E03006]: unexpected name in this position\n   \u250c\u2500 ./sources/temp_contract.move:50:20\n   \u2502\n50 \u2502             admin: signer::address_of(admin),\n   \u2502                    ^^^^^^ Could not resolve the name 'signer'\n\nerror[E04004]: expected a single non-reference type\n   \u250c\u2500 ./sources/temp_contract.move:54:36\n   \u2502\n26 \u2502         validator_delegations: vector<(address, u64)>,\n   \u2502                                       -------------- Expected a single non-reference type, but found: '(address, u64)'\n   \u00b7\n54 \u2502             validator_delegations: vector::empty(),\n   \u2502                                    ^^^^^^^^^^^^^^^ Invalid type argument\n\nerror[E03005]: unbound unscoped name\n   \u250c\u2500 ./sources/temp_contract.move:56:9\n   \u2502\n56 \u2502         move_to(admin, pool);\n   \u2502         ^^^^^^^ Unbound function 'move_to' in current scope\n\nwarning[W09002]: unused variable\n   \u250c\u2500 ./sources/temp_contract.move:71:9\n   \u2502\n71 \u2502         user: &signer,\n   \u2502         ^^^^ Unused parameter 'user'. Consider removing or prefixing with an underscore: '_user'\n   \u2502\n   = This warning can be suppressed with '#[allow(unused_variable)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nerror[E03008]: too few type arguments\n   \u250c\u2500 ./sources/temp_contract.move:72:19\n   \u2502\n72 \u2502         sui_coin: Coin,\n   \u2502                   ^^^^ Invalid instantiation of 'sui::coin::Coin'. Expected 1 type argument(s) but got 0\n\nerror[E03005]: unbound unscoped name\n   \u250c\u2500 ./sources/temp_contract.move:77:24\n   \u2502\n77 \u2502         let pool_ref = borrow_global_mut<StakingPool>(pool_addr);\n   \u2502                        ^^^^^^^^^^^^^^^^^ Unbound function 'borrow_global_mut' in current scope\n\nerror[E01002]: unexpected token\n   \u250c\u2500 ./sources/temp_contract.move:93:9\n   \u2502\n93 \u2502         pool_ref.total_staked = pool_ref.total_staked + amount;\n   \u2502         ^^^^^^^^\n   \u2502         \u2502\n   \u2502         Unexpected 'pool_ref'\n   \u2502         Expected ';'\n\nerror[E04010]: cannot infer type\n   \u250c\u2500 ./sources/temp_contract.move:98:19\n   \u2502\n98 \u2502         if (idx < vector::length(&pool_ref.validator_delegations)) {\n   \u2502                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Could not infer this type. Try adding an annotation\n\nwarning[W09002]: unused variable\n   \u250c\u2500 ./sources/temp_contract.move:99:18\n   \u2502\n99 \u2502             let (val, delegated_amount) = *vector::borrow_mut(&mut pool_ref.validator_delegations, idx);\n   \u2502                  ^^^ Unused local variable 'val'. Consider removing or prefixing with an underscore: '_val'\n   \u2502\n   = This warning can be suppressed with '#[allow(unused_variable)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nerror[E04010]: cannot infer type\n   \u250c\u2500 ./sources/temp_contract.move:99:18\n   \u2502\n99 \u2502             let (val, delegated_amount) = *vector::borrow_mut(&mut pool_ref.validator_delegations, idx);\n   \u2502                  ^^^ Could not infer this type. Try adding an annotation\n\nerror[E04004]: expected a single non-reference type\n   \u250c\u2500 ./sources/temp_contract.move:99:44\n   \u2502\n99 \u2502             let (val, delegated_amount) = *vector::borrow_mut(&mut pool_ref.validator_delegations, idx);\n   \u2502                 -----------------------    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Invalid type argument\n   \u2502                 \u2502                           \n   \u2502                 Expected a single non-reference type, but found: '(_, u64)'\n\nerror[E04010]: cannot infer type\n    \u250c\u2500 ./sources/temp_contract.move:100:13\n    \u2502\n100 \u2502             vector::borrow_mut(&mut pool_ref.validator_delegations, idx).1 = delegated_amount + amount;\n    \u2502             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Could not infer this type. Try adding an annotation\n\nerror[E04010]: cannot infer type\n    \u250c\u2500 ./sources/temp_contract.move:100:13\n    \u2502\n100 \u2502             vector::borrow_mut(&mut pool_ref.validator_delegations, idx).1 = delegated_amount + amount;\n    \u2502             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    \u2502             \u2502\n    \u2502             Unbound field '1'\n    \u2502             Could not infer the type before field access. Try annotating here\n\nerror[E04004]: expected a single non-reference type\n    \u250c\u2500 ./sources/temp_contract.move:102:13\n    \u2502\n102 \u2502             vector::push_back(&mut pool_ref.validator_delegations, (validator, amount));\n    \u2502             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    \u2502             \u2502                                                      \u2502\n    \u2502             \u2502                                                      Expected a single non-reference type, but found: '(address, u64)'\n    \u2502             Invalid type argument\n\nerror[E01002]: unexpected token\n    \u250c\u2500 ./sources/temp_contract.move:106:9\n    \u2502\n106 \u2502         destroy(sui_coin);\n    \u2502         ^^^^^^^\n    \u2502         \u2502\n    \u2502         Unexpected 'destroy'\n    \u2502         Expected ';'\n\nerror[E03005]: unbound unscoped name\n    \u250c\u2500 ./sources/temp_contract.move:106:9\n    \u2502\n106 \u2502         destroy(sui_coin);\n    \u2502         ^^^^^^^ Unbound function 'destroy' in current scope\n\nerror[E03006]: unexpected name in this position\n    \u250c\u2500 ./sources/temp_contract.move:110:20\n    \u2502\n110 \u2502             owner: signer::address_of(user),\n    \u2502                    ^^^^^^ Could not resolve the name 'signer'\n\nerror[E03008]: too few type arguments\n    \u250c\u2500 ./sources/temp_contract.move:126:8\n    \u2502\n126 \u2502     ): Coin {\n    \u2502        ^^^^ Invalid instantiation of 'sui::coin::Coin'. Expected 1 type argument(s) but got 0\n\nerror[E01002]: unexpected token\n    \u250c\u2500 ./sources/temp_contract.move:132:9\n    \u2502\n132 \u2502         let pool_ref = borrow_global_mut<StakingPool>(pool_addr);\n    \u2502         ^^^\n    \u2502         \u2502\n    \u2502         Unexpected 'let'\n    \u2502         Expected ';'\n\nerror[E03005]: unbound unscoped name\n    \u250c\u2500 ./sources/temp_contract.move:132:24\n    \u2502\n132 \u2502         let pool_ref = borrow_global_mut<StakingPool>(pool_addr);\n    \u2502                        ^^^^^^^^^^^^^^^^^ Unbound function 'borrow_global_mut' in current scope\n\nerror[E03005]: unbound unscoped name\n    \u250c\u2500 ./sources/temp_contract.move:148:29\n    \u2502\n148 \u2502         let unstaked_coin = create(user_value);\n    \u2502                             ^^^^^^ Unbound function 'create' in current scope\n\nwarning[W09002]: unused variable\n    \u250c\u2500 ./sources/temp_contract.move:164:9\n    \u2502\n164 \u2502         admin: &signer,\n    \u2502         ^^^^^ Unused parameter 'admin'. Consider removing or prefixing with an underscore: '_admin'\n    \u2502\n    = This warning can be suppressed with '#[allow(unused_variable)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nerror[E03008]: too few type arguments\n    \u250c\u2500 ./sources/temp_contract.move:165:18\n    \u2502\n165 \u2502         rewards: Coin\n    \u2502                  ^^^^ Invalid instantiation of 'sui::coin::Coin'. Expected 1 type argument(s) but got 0\n\nerror[E03005]: unbound unscoped name\n    \u250c\u2500 ./sources/temp_contract.move:167:24\n    \u2502\n167 \u2502         let pool_ref = borrow_global_mut<StakingPool>(pool_addr);\n    \u2502                        ^^^^^^^^^^^^^^^^^ Unbound function 'borrow_global_mut' in current scope\n\nerror[E03006]: unexpected name in this position\n    \u250c\u2500 ./sources/temp_contract.move:168:13\n    \u2502\n168 \u2502         if (signer::address_of(admin) != pool_ref.admin) {\n    \u2502             ^^^^^^ Could not resolve the name 'signer'\n\nerror[E03005]: unbound unscoped name\n    \u250c\u2500 ./sources/temp_contract.move:173:9\n    \u2502\n173 \u2502         destroy(rewards);\n    \u2502         ^^^^^^^ Unbound function 'destroy' in current scope\n\nwarning[W09002]: unused variable\n    \u250c\u2500 ./sources/temp_contract.move:181:9\n    \u2502\n181 \u2502         admin: &signer,\n    \u2502         ^^^^^ Unused parameter 'admin'. Consider removing or prefixing with an underscore: '_admin'\n    \u2502\n    = This warning can be suppressed with '#[allow(unused_variable)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nerror[E03005]: unbound unscoped name\n    \u250c\u2500 ./sources/temp_contract.move:185:24\n    \u2502\n185 \u2502         let pool_ref = borrow_global_mut<StakingPool>(pool_addr);\n    \u2502                        ^^^^^^^^^^^^^^^^^ Unbound function 'borrow_global_mut' in current scope\n\nerror[E03006]: unexpected name in this position\n    \u250c\u2500 ./sources/temp_contract.move:186:13\n    \u2502\n186 \u2502         if (signer::address_of(admin) != pool_ref.admin) {\n    \u2502             ^^^^^^ Could not resolve the name 'signer'\n\nerror[E04010]: cannot infer type\n    \u250c\u2500 ./sources/temp_contract.move:190:19\n    \u2502\n190 \u2502         if (idx < vector::length(&pool_ref.validator_delegations)) {\n    \u2502                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Could not infer this type. Try adding an annotation\n\nwarning[W09002]: unused variable\n    \u250c\u2500 ./sources/temp_contract.move:191:18\n    \u2502\n191 \u2502             let (val, delegated_amount) = *vector::borrow_mut(&mut pool_ref.validator_delegations, idx);\n    \u2502                  ^^^ Unused local variable 'val'. Consider removing or prefixing with an underscore: '_val'\n    \u2502\n    = This warning can be suppressed with '#[allow(unused_variable)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nerror[E04010]: cannot infer type\n    \u250c\u2500 ./sources/temp_contract.move:191:18\n    \u2502\n191 \u2502             let (val, delegated_amount) = *vector::borrow_mut(&mut pool_ref.validator_delegations, idx);\n    \u2502                  ^^^ Could not infer this type. Try adding an annotation\n\nerror[E04004]: expected a single non-reference type\n    \u250c\u2500 ./sources/temp_contract.move:191:44\n    \u2502\n191 \u2502             let (val, delegated_amount) = *vector::borrow_mut(&mut pool_ref.validator_delegations, idx);\n    \u2502                 -----------------------    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Invalid type argument\n    \u2502                 \u2502                           \n    \u2502                 Expected a single non-reference type, but found: '(_, u64)'\n\nerror[E04010]: cannot infer type\n    \u250c\u2500 ./sources/temp_contract.move:192:13\n    \u2502\n192 \u2502             vector::borrow_mut(&mut pool_ref.validator_delegations, idx).1 = delegated_amount + amount;\n    \u2502             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Could not infer this type. Try adding an annotation\n\nerror[E04010]: cannot infer type\n    \u250c\u2500 ./sources/temp_contract.move:192:13\n    \u2502\n192 \u2502             vector::borrow_mut(&mut pool_ref.validator_delegations, idx).1 = delegated_amount + amount;\n    \u2502             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    \u2502             \u2502\n    \u2502             Unbound field '1'\n    \u2502             Could not infer the type before field access. Try annotating here\n\nerror[E04004]: expected a single non-reference type\n    \u250c\u2500 ./sources/temp_contract.move:194:13\n    \u2502\n194 \u2502             vector::push_back(&mut pool_ref.validator_delegations, (validator, amount));\n    \u2502             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    \u2502             \u2502                                                      \u2502\n    \u2502             \u2502                                                      Expected a single non-reference type, but found: '(address, u64)'\n    \u2502             Invalid type argument\n\nerror[E04004]: expected a single non-reference type\n    \u250c\u2500 ./sources/temp_contract.move:204:42\n    \u2502\n204 \u2502     fun index_of_validator(delegations: &vector<(address, u64)>, validator: address): u64 {\n    \u2502                                          ^^^^^^^^^^^^^^^^^^^^^^\n    \u2502                                          \u2502      \u2502\n    \u2502                                          \u2502      Expected a single non-reference type, but found: '(address, u64)'\n    \u2502                                          Invalid type argument\n\nerror[E04004]: expected a single non-reference type\n    \u250c\u2500 ./sources/temp_contract.move:205:19\n    \u2502\n204 \u2502     fun index_of_validator(delegations: &vector<(address, u64)>, validator: address): u64 {\n    \u2502                                                 -------------- Expected a single non-reference type, but found: '(address, u64)'\n205 \u2502         let len = vector::length(delegations);\n    \u2502                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ Invalid type argument\n\nerror[E04004]: expected a single non-reference type\n    \u250c\u2500 ./sources/temp_contract.move:208:29\n    \u2502\n204 \u2502     fun index_of_validator(delegations: &vector<(address, u64)>, validator: address): u64 {\n    \u2502                                                 -------------- Expected a single non-reference type, but found: '(address, u64)'\n    \u00b7\n208 \u2502             let (val, _) = *vector::borrow(delegations, i);\n    \u2502                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Invalid type argument\n\n",
      "metadata": {
        "iteration": 1,
        "timestamp": 1740789974.944149,
        "error_stats": {
          "errors": 48,
          "compiler_warnings": 6,
          "linter_warnings": 0
        },
        "error_codes": {
          "W21002": {
            "count": 1,
            "message": "duplicate alias",
            "level": "Warning"
          },
          "E02003": {
            "count": 1,
            "message": "unbound module",
            "level": "BlockingError"
          },
          "E03003": {
            "count": 2,
            "message": "unbound module member",
            "level": "BlockingError"
          },
          "N03001": {
            "count": 2,
            "message": "invalid modifier",
            "level": "NonblockingError"
          },
          "N07002": {
            "count": 2,
            "message": "invalid object declaration",
            "level": "NonblockingError"
          },
          "E04004": {
            "count": 9,
            "message": "expected a single non-reference type",
            "level": "BlockingError"
          },
          "E06003": {
            "count": 4,
            "message": "unexpected name in this position",
            "level": "BlockingError"
          },
          "E05003": {
            "count": 8,
            "message": "unbound unscoped name",
            "level": "BlockingError"
          },
          "W02009": {
            "count": 5,
            "message": "unused variable",
            "level": "Warning"
          },
          "E08003": {
            "count": 3,
            "message": "too few type arguments",
            "level": "BlockingError"
          },
          "N02001": {
            "count": 3,
            "message": "unexpected token",
            "level": "NonblockingError"
          },
          "E10004": {
            "count": 8,
            "message": "cannot infer type",
            "level": "BlockingError"
          }
        }
      }
    },
    {
      "input": "module 0x0::my_module {\n\n    use std::vector;\n    // Import key functions for object management.\n    use sui::object::{UID, move_to, borrow_global_mut, destroy_object};\n    // Import coin module functions. We assume that a mint function exists for demonstration.\n    use sui::coin::{Coin, mint};\n    use sui::tx_context::TxContext;\n\n    // Define a phantom type so we can refer to the native SUI coin as Coin<SUI>\n    struct SUI has store {}\n\n    // A delegation record representing the amount staked with a particular validator.\n    struct Delegation has copy, drop, store, key {\n        validator: address,\n        delegated: u64,\n    }\n\n    // The staking pool is an on-chain object.\n    // NOTE: Resources with the key ability must have a UID as their first field.\n    struct StakingPool has key {\n        id: UID,\n        admin: address,\n        total_staked: u64,\n        // A vector of delegation records, one per validator.\n        validator_delegations: vector<Delegation>,\n        // Total rewards accrued in the pool.\n        rewards: u64,\n    }\n\n    // A liquid ticket represents a user's staked SUI position.\n    struct LiquidTicket has key, store {\n        id: UID,\n        owner: address,\n        // The amount of SUI this ticket represents.\n        amount: u64,\n        // Lock period timestamp. Zero indicates no lock.\n        lock_until: u64,\n    }\n\n    ////////////////////////////////\n    //    Pool Initialization     //\n    ////////////////////////////////\n\n    /// Initializes a new staking pool.\n    /// The caller becomes the admin of the pool.\n    public fun initialize_pool(admin: &signer, ctx: &mut TxContext) {\n        let pool = StakingPool {\n            id: UID::new(ctx),\n            admin: TxContext::sender(ctx),\n            total_staked: 0,\n            validator_delegations: vector::empty<Delegation>(),\n            rewards: 0,\n        };\n        move_to(admin, pool);\n    }\n\n    ////////////////////////////////\n    //       Helper Function      //\n    ////////////////////////////////\n\n    /// Returns the index of the delegation for a given validator in the delegations vector.\n    /// If not found, returns the current length of the vector.\n    fun index_of_validator(delegations: &vector<Delegation>, validator: address): u64 {\n        let len = vector::length<Delegation>(delegations);\n        let i = 0;\n        while (i < len) {\n            let delegation = *vector::borrow<Delegation>(delegations, i);\n            if (delegation.validator == validator) {\n                return i;\n            };\n            i = i + 1;\n        };\n        return len;\n    }\n\n    ////////////////////////////////\n    //         Staking            //\n    ////////////////////////////////\n\n    /// Stake a given amount of SUI to a specific validator.\n    ///\n    /// The caller must provide a SUI coin (Coin<SUI>) having at least the staked amount.\n    /// In a production contract you would split the coin (leaving any remainder with the caller).\n    ///\n    /// A liquid ticket is issued to represent the user's staked position.\n    public fun stake(\n        user: &signer,\n        sui_coin: Coin<SUI>,\n        amount: u64,\n        validator: address,\n        pool_addr: address,\n        ctx: &mut TxContext\n    ) {\n        // Update the staking pool.\n        let pool_ref = borrow_global_mut<StakingPool>(pool_addr);\n        pool_ref.total_staked = pool_ref.total_staked + amount;\n        let idx = index_of_validator(&pool_ref.validator_delegations, validator);\n        if (idx < vector::length<Delegation>(&pool_ref.validator_delegations)) {\n            let delegation_ref = vector::borrow_mut<Delegation>(&mut pool_ref.validator_delegations, idx);\n            delegation_ref.delegated = delegation_ref.delegated + amount;\n        } else {\n            let new_delegation = Delegation { validator, delegated: amount };\n            vector::push_back<Delegation>(&mut pool_ref.validator_delegations, new_delegation);\n        };\n        // Destroy the provided SUI coin as its value is now held by the pool.\n        destroy_object(sui_coin);\n        // Issue a liquid ticket representing the staked position.\n        let ticket = LiquidTicket {\n            id: UID::new(ctx),\n            owner: TxContext::sender(ctx),\n            amount,\n            lock_until: 0, // No lock period set in this example.\n        };\n        move_to(user, ticket);\n    }\n\n    ////////////////////////////////\n    //         Unstaking          //\n    ////////////////////////////////\n\n    /// Unstake function: Redeem a liquid ticket to retrieve the staked SUI.\n    ///\n    /// The liquid ticket must belong to the caller.\n    /// Returns a newly minted Coin<SUI> of the unstaked amount.\n    public fun unstake(\n        user: &signer,\n        pool_addr: address,\n        ticket: LiquidTicket,\n        ctx: &mut TxContext\n    ): Coin<SUI> {\n        // Ensure the liquid ticket belongs to the caller.\n        assert!(ticket.owner == TxContext::sender(ctx), 100);\n        let pool_ref = borrow_global_mut<StakingPool>(pool_addr);\n        // For simplicity, we do not enforce a lock period here.\n        assert!(pool_ref.total_staked >= ticket.amount, 101);\n        pool_ref.total_staked = pool_ref.total_staked - ticket.amount;\n        let unstake_amount = ticket.amount;\n        // Destroy the liquid ticket.\n        destroy_object(ticket);\n        // Mint new SUI coins for the unstaked amount.\n        let unstaked_coin = mint<SUI>(unstake_amount, ctx);\n        unstaked_coin\n    }\n\n    ////////////////////////////////\n    //      Reward Claiming       //\n    ////////////////////////////////\n\n    /// Allows the admin to claim the accrued rewards in the pool.\n    ///\n    /// Only the admin can call this function.\n    /// Returns a Coin<SUI> representing the claimed rewards.\n    public fun claim_rewards(\n        admin: &signer,\n        pool_addr: address,\n        ctx: &mut TxContext\n    ): Coin<SUI> {\n        let pool_ref = borrow_global_mut<StakingPool>(pool_addr);\n        // Only the admin is allowed to claim rewards.\n        assert!(TxContext::sender(ctx) == pool_ref.admin, 200);\n        let rewards_amount = pool_ref.rewards;\n        pool_ref.rewards = 0;\n        let reward_coin = mint<SUI>(rewards_amount, ctx);\n        reward_coin\n    }\n\n    ////////////////////////////////\n    //         Delegation         //\n    ////////////////////////////////\n\n    /// Delegate additional SUI stake to a validator.\n    ///\n    /// The caller is assumed to have transferred the appropriate SUI off-chain.\n    public fun delegate(\n        user: &signer,\n        pool_addr: address,\n        validator: address,\n        amount: u64,\n        ctx: &mut TxContext\n    ) {\n        let pool_ref = borrow_global_mut<StakingPool>(pool_addr);\n        pool_ref.total_staked = pool_ref.total_staked + amount;\n        let idx = index_of_validator(&pool_ref.validator_delegations, validator);\n        if (idx < vector::length<Delegation>(&pool_ref.validator_delegations)) {\n            let delegation_ref = vector::borrow_mut<Delegation>(&mut pool_ref.validator_delegations, idx);\n            delegation_ref.delegated = delegation_ref.delegated + amount;\n        } else {\n            let new_delegation = Delegation { validator, delegated: amount };\n            vector::push_back<Delegation>(&mut pool_ref.validator_delegations, new_delegation);\n        };\n        // The transfer of SUI is assumed to be handled separately.\n    }\n}",
      "output": "UPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git\nINCLUDING DEPENDENCY Sui\nINCLUDING DEPENDENCY MoveStdlib\nBUILDING TempContract\nwarning[W02021]: duplicate alias\n  \u250c\u2500 ./sources/temp_contract.move:3:14\n  \u2502\n3 \u2502     use std::vector;\n  \u2502              ^^^^^^ Unnecessary alias 'vector' for module 'std::vector'. This alias is provided by default\n  \u2502\n  = This warning can be suppressed with '#[allow(duplicate_alias)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nwarning[W02021]: duplicate alias\n  \u250c\u2500 ./sources/temp_contract.move:5:23\n  \u2502\n5 \u2502     use sui::object::{UID, move_to, borrow_global_mut, destroy_object};\n  \u2502                       ^^^ Unnecessary alias 'UID' for module member 'sui::object::UID'. This alias is provided by default\n  \u2502\n  = This warning can be suppressed with '#[allow(duplicate_alias)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nerror[E03003]: unbound module member\n  \u250c\u2500 ./sources/temp_contract.move:5:28\n  \u2502\n5 \u2502     use sui::object::{UID, move_to, borrow_global_mut, destroy_object};\n  \u2502                            ^^^^^^^ Invalid 'use'. Unbound member 'move_to' in module 'sui::object'\n  \u2502\n  \u250c\u2500 /Users/kz/.move/https___github_com_MystenLabs_sui_git_framework__testnet/crates/sui-framework/packages/sui-framework/sources/object.move:5:13\n  \u2502\n5 \u2502 module sui::object;\n  \u2502             ------ Module 'sui::object' declared here\n\nerror[E03003]: unbound module member\n  \u250c\u2500 ./sources/temp_contract.move:5:37\n  \u2502\n5 \u2502     use sui::object::{UID, move_to, borrow_global_mut, destroy_object};\n  \u2502                                     ^^^^^^^^^^^^^^^^^ Invalid 'use'. Unbound member 'borrow_global_mut' in module 'sui::object'\n  \u2502\n  \u250c\u2500 /Users/kz/.move/https___github_com_MystenLabs_sui_git_framework__testnet/crates/sui-framework/packages/sui-framework/sources/object.move:5:13\n  \u2502\n5 \u2502 module sui::object;\n  \u2502             ------ Module 'sui::object' declared here\n\nerror[E03003]: unbound module member\n  \u250c\u2500 ./sources/temp_contract.move:5:56\n  \u2502\n5 \u2502     use sui::object::{UID, move_to, borrow_global_mut, destroy_object};\n  \u2502                                                        ^^^^^^^^^^^^^^ Invalid 'use'. Unbound member 'destroy_object' in module 'sui::object'\n  \u2502\n  \u250c\u2500 /Users/kz/.move/https___github_com_MystenLabs_sui_git_framework__testnet/crates/sui-framework/packages/sui-framework/sources/object.move:5:13\n  \u2502\n5 \u2502 module sui::object;\n  \u2502             ------ Module 'sui::object' declared here\n\nwarning[W02021]: duplicate alias\n  \u250c\u2500 ./sources/temp_contract.move:8:26\n  \u2502\n8 \u2502     use sui::tx_context::TxContext;\n  \u2502                          ^^^^^^^^^ Unnecessary alias 'TxContext' for module member 'sui::tx_context::TxContext'. This alias is provided by default\n  \u2502\n  = This warning can be suppressed with '#[allow(duplicate_alias)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nerror[E01003]: invalid modifier\n   \u250c\u2500 ./sources/temp_contract.move:11:5\n   \u2502\n11 \u2502     struct SUI has store {}\n   \u2502     ^^^^^^ Invalid struct declaration. Internal struct declarations are not yet supported\n   \u2502\n   = Visibility annotations are required on struct declarations from the Move 2024 edition onwards.\n\nerror[E01003]: invalid modifier\n   \u250c\u2500 ./sources/temp_contract.move:14:5\n   \u2502\n14 \u2502     struct Delegation has copy, drop, store, key {\n   \u2502     ^^^^^^ Invalid struct declaration. Internal struct declarations are not yet supported\n   \u2502\n   = Visibility annotations are required on struct declarations from the Move 2024 edition onwards.\n\nerror[Sui E02007]: invalid object declaration\n   \u250c\u2500 ./sources/temp_contract.move:15:9\n   \u2502\n14 \u2502     struct Delegation has copy, drop, store, key {\n   \u2502                                              --- The 'key' ability is used to declare objects in Sui\n15 \u2502         validator: address,\n   \u2502         ^^^^^^^^^ Invalid object 'Delegation'. Structs with the 'key' ability must have 'id: sui::object::UID' as their first field\n\nerror[E01003]: invalid modifier\n   \u250c\u2500 ./sources/temp_contract.move:21:5\n   \u2502\n21 \u2502     struct StakingPool has key {\n   \u2502     ^^^^^^ Invalid struct declaration. Internal struct declarations are not yet supported\n   \u2502\n   = Visibility annotations are required on struct declarations from the Move 2024 edition onwards.\n\nerror[E01003]: invalid modifier\n   \u250c\u2500 ./sources/temp_contract.move:32:5\n   \u2502\n32 \u2502     struct LiquidTicket has key, store {\n   \u2502     ^^^^^^ Invalid struct declaration. Internal struct declarations are not yet supported\n   \u2502\n   = Visibility annotations are required on struct declarations from the Move 2024 edition onwards.\n\nerror[E03006]: unexpected name in this position\n   \u250c\u2500 ./sources/temp_contract.move:49:17\n   \u2502\n49 \u2502             id: UID::new(ctx),\n   \u2502                 ^^^ Invalid construction. Expected an enum\n   \u2502\n   \u250c\u2500 /Users/kz/.move/https___github_com_MystenLabs_sui_git_framework__testnet/crates/sui-framework/packages/sui-framework/sources/object.move:69:15\n   \u2502\n69 \u2502 public struct UID has store {\n   \u2502               --- But 'UID' is an struct\n\nerror[E03006]: unexpected name in this position\n   \u250c\u2500 ./sources/temp_contract.move:50:20\n   \u2502\n50 \u2502             admin: TxContext::sender(ctx),\n   \u2502                    ^^^^^^^^^ Invalid construction. Expected an enum\n   \u2502\n   \u250c\u2500 /Users/kz/.move/https___github_com_MystenLabs_sui_git_framework__testnet/crates/sui-framework/packages/sui-framework/sources/tx_context.move:21:15\n   \u2502\n21 \u2502 public struct TxContext has drop {\n   \u2502               --------- But 'TxContext' is an struct\n\nerror[E03005]: unbound unscoped name\n   \u250c\u2500 ./sources/temp_contract.move:55:9\n   \u2502\n55 \u2502         move_to(admin, pool);\n   \u2502         ^^^^^^^ Unbound function 'move_to' in current scope\n\nerror[E04007]: incompatible types\n   \u250c\u2500 ./sources/temp_contract.move:74:19\n   \u2502\n64 \u2502     fun index_of_validator(delegations: &vector<Delegation>, validator: address): u64 {\n   \u2502                                                                                   --- Expected: 'u64'\n   \u00b7\n74 \u2502         return len;\n   \u2502                   ^\n   \u2502                   \u2502\n   \u2502                   Invalid return expression\n   \u2502                   Given: '()'\n\nerror[E03005]: unbound unscoped name\n   \u250c\u2500 ./sources/temp_contract.move:96:24\n   \u2502\n96 \u2502         let pool_ref = borrow_global_mut<StakingPool>(pool_addr);\n   \u2502                        ^^^^^^^^^^^^^^^^^ Unbound function 'borrow_global_mut' in current scope\n\nerror[E03005]: unbound unscoped name\n    \u250c\u2500 ./sources/temp_contract.move:107:9\n    \u2502\n107 \u2502         destroy_object(sui_coin);\n    \u2502         ^^^^^^^^^^^^^^ Unbound function 'destroy_object' in current scope\n\nerror[E03006]: unexpected name in this position\n    \u250c\u2500 ./sources/temp_contract.move:110:17\n    \u2502\n110 \u2502             id: UID::new(ctx),\n    \u2502                 ^^^ Invalid construction. Expected an enum\n    \u2502\n    \u250c\u2500 /Users/kz/.move/https___github_com_MystenLabs_sui_git_framework__testnet/crates/sui-framework/packages/sui-framework/sources/object.move:69:15\n    \u2502\n 69 \u2502 public struct UID has store {\n    \u2502               --- But 'UID' is an struct\n\nerror[E03006]: unexpected name in this position\n    \u250c\u2500 ./sources/temp_contract.move:111:20\n    \u2502\n111 \u2502             owner: TxContext::sender(ctx),\n    \u2502                    ^^^^^^^^^ Invalid construction. Expected an enum\n    \u2502\n    \u250c\u2500 /Users/kz/.move/https___github_com_MystenLabs_sui_git_framework__testnet/crates/sui-framework/packages/sui-framework/sources/tx_context.move:21:15\n    \u2502\n 21 \u2502 public struct TxContext has drop {\n    \u2502               --------- But 'TxContext' is an struct\n\nerror[E03005]: unbound unscoped name\n    \u250c\u2500 ./sources/temp_contract.move:115:9\n    \u2502\n115 \u2502         move_to(user, ticket);\n    \u2502         ^^^^^^^ Unbound function 'move_to' in current scope\n\nwarning[W09002]: unused variable\n    \u250c\u2500 ./sources/temp_contract.move:127:9\n    \u2502\n127 \u2502         user: &signer,\n    \u2502         ^^^^ Unused parameter 'user'. Consider removing or prefixing with an underscore: '_user'\n    \u2502\n    = This warning can be suppressed with '#[allow(unused_variable)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nerror[E03006]: unexpected name in this position\n    \u250c\u2500 ./sources/temp_contract.move:133:33\n    \u2502\n133 \u2502         assert!(ticket.owner == TxContext::sender(ctx), 100);\n    \u2502                                 ^^^^^^^^^ Invalid construction. Expected an enum\n    \u2502\n    \u250c\u2500 /Users/kz/.move/https___github_com_MystenLabs_sui_git_framework__testnet/crates/sui-framework/packages/sui-framework/sources/tx_context.move:21:15\n    \u2502\n 21 \u2502 public struct TxContext has drop {\n    \u2502               --------- But 'TxContext' is an struct\n\nerror[E03005]: unbound unscoped name\n    \u250c\u2500 ./sources/temp_contract.move:134:24\n    \u2502\n134 \u2502         let pool_ref = borrow_global_mut<StakingPool>(pool_addr);\n    \u2502                        ^^^^^^^^^^^^^^^^^ Unbound function 'borrow_global_mut' in current scope\n\nerror[E03005]: unbound unscoped name\n    \u250c\u2500 ./sources/temp_contract.move:140:9\n    \u2502\n140 \u2502         destroy_object(ticket);\n    \u2502         ^^^^^^^^^^^^^^ Unbound function 'destroy_object' in current scope\n\nerror[E04007]: incompatible types\n    \u250c\u2500 ./sources/temp_contract.move:142:29\n    \u2502\n 36 \u2502         amount: u64,\n    \u2502                 --- Given: 'u64'\n    \u00b7\n142 \u2502         let unstaked_coin = mint<SUI>(unstake_amount, ctx);\n    \u2502                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Invalid call of 'sui::coin::mint'. Invalid argument for parameter 'cap'\n    \u2502\n    \u250c\u2500 /Users/kz/.move/https___github_com_MystenLabs_sui_git_framework__testnet/crates/sui-framework/packages/sui-framework/sources/coin.move:299:25\n    \u2502\n299 \u2502 public fun mint<T>(cap: &mut TreasuryCap<T>, value: u64, ctx: &mut TxContext): Coin<T> {\n    \u2502                         ------------------- Expected: '&mut sui::coin::TreasuryCap<0x0::my_module::SUI>'\n\nerror[E04007]: incompatible types\n    \u250c\u2500 ./sources/temp_contract.move:142:29\n    \u2502\n130 \u2502         ctx: &mut TxContext\n    \u2502              -------------- Given: '&mut sui::tx_context::TxContext'\n    \u00b7\n142 \u2502         let unstaked_coin = mint<SUI>(unstake_amount, ctx);\n    \u2502                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Invalid call of 'sui::coin::mint'. Invalid argument for parameter 'value'\n    \u2502\n    \u250c\u2500 /Users/kz/.move/https___github_com_MystenLabs_sui_git_framework__testnet/crates/sui-framework/packages/sui-framework/sources/coin.move:299:53\n    \u2502\n299 \u2502 public fun mint<T>(cap: &mut TreasuryCap<T>, value: u64, ctx: &mut TxContext): Coin<T> {\n    \u2502                                                     --- Expected: 'u64'\n\nerror[E04016]: too few arguments\n    \u250c\u2500 ./sources/temp_contract.move:142:29\n    \u2502\n142 \u2502         let unstaked_coin = mint<SUI>(unstake_amount, ctx);\n    \u2502                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    \u2502                             \u2502        \u2502\n    \u2502                             \u2502        Found 2 argument(s) here\n    \u2502                             Invalid call of 'sui::coin::mint'. The call expected 3 argument(s) but got 2\n\nwarning[W09002]: unused variable\n    \u250c\u2500 ./sources/temp_contract.move:155:9\n    \u2502\n155 \u2502         admin: &signer,\n    \u2502         ^^^^^ Unused parameter 'admin'. Consider removing or prefixing with an underscore: '_admin'\n    \u2502\n    = This warning can be suppressed with '#[allow(unused_variable)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nerror[E03005]: unbound unscoped name\n    \u250c\u2500 ./sources/temp_contract.move:159:24\n    \u2502\n159 \u2502         let pool_ref = borrow_global_mut<StakingPool>(pool_addr);\n    \u2502                        ^^^^^^^^^^^^^^^^^ Unbound function 'borrow_global_mut' in current scope\n\nerror[E03006]: unexpected name in this position\n    \u250c\u2500 ./sources/temp_contract.move:161:17\n    \u2502\n161 \u2502         assert!(TxContext::sender(ctx) == pool_ref.admin, 200);\n    \u2502                 ^^^^^^^^^ Invalid construction. Expected an enum\n    \u2502\n    \u250c\u2500 /Users/kz/.move/https___github_com_MystenLabs_sui_git_framework__testnet/crates/sui-framework/packages/sui-framework/sources/tx_context.move:21:15\n    \u2502\n 21 \u2502 public struct TxContext has drop {\n    \u2502               --------- But 'TxContext' is an struct\n\nerror[E04007]: incompatible types\n    \u250c\u2500 ./sources/temp_contract.move:164:27\n    \u2502\n157 \u2502         ctx: &mut TxContext\n    \u2502              -------------- Given: '&mut sui::tx_context::TxContext'\n    \u00b7\n164 \u2502         let reward_coin = mint<SUI>(rewards_amount, ctx);\n    \u2502                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Invalid call of 'sui::coin::mint'. Invalid argument for parameter 'value'\n    \u2502\n    \u250c\u2500 /Users/kz/.move/https___github_com_MystenLabs_sui_git_framework__testnet/crates/sui-framework/packages/sui-framework/sources/coin.move:299:53\n    \u2502\n299 \u2502 public fun mint<T>(cap: &mut TreasuryCap<T>, value: u64, ctx: &mut TxContext): Coin<T> {\n    \u2502                                                     --- Expected: 'u64'\n\nerror[E04016]: too few arguments\n    \u250c\u2500 ./sources/temp_contract.move:164:27\n    \u2502\n164 \u2502         let reward_coin = mint<SUI>(rewards_amount, ctx);\n    \u2502                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    \u2502                           \u2502        \u2502\n    \u2502                           \u2502        Found 2 argument(s) here\n    \u2502                           Invalid call of 'sui::coin::mint'. The call expected 3 argument(s) but got 2\n\nwarning[W09002]: unused variable\n    \u250c\u2500 ./sources/temp_contract.move:176:9\n    \u2502\n176 \u2502         user: &signer,\n    \u2502         ^^^^ Unused parameter 'user'. Consider removing or prefixing with an underscore: '_user'\n    \u2502\n    = This warning can be suppressed with '#[allow(unused_variable)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nwarning[W09002]: unused variable\n    \u250c\u2500 ./sources/temp_contract.move:180:9\n    \u2502\n180 \u2502         ctx: &mut TxContext\n    \u2502         ^^^ Unused parameter 'ctx'. Consider removing or prefixing with an underscore: '_ctx'\n    \u2502\n    = This warning can be suppressed with '#[allow(unused_variable)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nerror[E03005]: unbound unscoped name\n    \u250c\u2500 ./sources/temp_contract.move:182:24\n    \u2502\n182 \u2502         let pool_ref = borrow_global_mut<StakingPool>(pool_addr);\n    \u2502                        ^^^^^^^^^^^^^^^^^ Unbound function 'borrow_global_mut' in current scope\n\n",
      "metadata": {
        "iteration": 2,
        "timestamp": 1740790014.370421,
        "error_stats": {
          "errors": 35,
          "compiler_warnings": 7,
          "linter_warnings": 0
        },
        "error_codes": {
          "W21002": {
            "count": 3,
            "message": "duplicate alias",
            "level": "Warning"
          },
          "E03003": {
            "count": 3,
            "message": "unbound module member",
            "level": "BlockingError"
          },
          "N03001": {
            "count": 4,
            "message": "invalid modifier",
            "level": "NonblockingError"
          },
          "N07002": {
            "count": 1,
            "message": "invalid object declaration",
            "level": "NonblockingError"
          },
          "E06003": {
            "count": 6,
            "message": "unexpected name in this position",
            "level": "BlockingError"
          },
          "E05003": {
            "count": 8,
            "message": "unbound unscoped name",
            "level": "BlockingError"
          },
          "E07004": {
            "count": 4,
            "message": "incompatible types",
            "level": "BlockingError"
          },
          "W02009": {
            "count": 4,
            "message": "unused variable",
            "level": "Warning"
          },
          "E16004": {
            "count": 2,
            "message": "too few arguments",
            "level": "BlockingError"
          }
        }
      }
    },
    {
      "input": "module 0x0::my_module {\n\n    use std::vector;\n    use std::signer;\n\n    // Import the UID type from the Sui framework.\n    use sui::object::UID;\n\n    //////////////////////////////////////////////////////////////////////\n    // Resource declarations\n    //////////////////////////////////////////////////////////////////////\n\n    // StakingPool resource stores global staking and reward information.\n    // It is created by the admin and is updated via staking, unstaking, delegation and reward distribution.\n    //\n    // Note: In Move 2024 edition, resources must be declared with public visibility and include an 'acquires' clause when needed.\n    public resource struct StakingPool has key {\n        admin: address,\n        total_stake: u64,\n        rewards: u64,\n        // List of delegations made from this pool.\n        delegations: vector<Delegation>,\n    }\n\n    // Delegation resource represents a delegation entry to a validator.\n    // Since it has the 'key' ability, the first field must be the unique ID.\n    public resource struct Delegation has key {\n        id: UID,\n        validator: address,\n        amount: u64,\n    }\n\n    // LiquidTicket represents the staked position of a user.\n    // It can be transferred and later redeemed for unstaking.\n    public resource struct LiquidTicket has key {\n        id: UID,\n        owner: address,\n        amount: u64,\n        pool_addr: address,\n        // Unix timestamp until which unstaking is locked.\n        lock_until: u64,\n    }\n\n    //////////////////////////////////////////////////////////////////////\n    // Initialization\n    //////////////////////////////////////////////////////////////////////\n\n    // Initialize a staking pool.\n    // The admin's signer is used to deposit the pool into their account.\n    public fun initialize_pool(admin: &signer) {\n        let pool = StakingPool {\n            admin: signer::address_of(admin),\n            total_stake: 0,\n            rewards: 0,\n            delegations: vector::empty<Delegation>(),\n        };\n        // Use the Move built-in 'move_to' to store the pool into the admin's account.\n        move_to<StakingPool>(admin, pool);\n    }\n\n    //////////////////////////////////////////////////////////////////////\n    // Staking Functionality\n    //////////////////////////////////////////////////////////////////////\n\n    // Stake SUI into the pool.\n    // For simulation purposes, the amount is provided as a u64.\n    // lock_duration: number of seconds to lock the stake\n    // now: current timestamp provided by the caller (in a real implementation, this is obtained from a trusted clock).\n    //\n    // Acquires the global resource StakingPool.\n    public fun stake(user: &signer, pool_addr: address, amount: u64, lock_duration: u64, now: u64) acquires StakingPool {\n        // Borrow a mutable reference to the pool.\n        let pool_ref = borrow_global_mut<StakingPool>(pool_addr);\n        pool_ref.total_stake = pool_ref.total_stake + amount;\n        // Create a new liquid ticket representing the staked position.\n        let ticket = LiquidTicket {\n            id: UID::new(),\n            owner: signer::address_of(user),\n            amount: amount,\n            pool_addr: pool_addr,\n            lock_until: now + lock_duration,\n        };\n        // Deposit the liquid ticket into the user's account.\n        move_to<LiquidTicket>(user, ticket);\n    }\n\n    // Unstake SUI by redeeming a liquid ticket.\n    // unstake_amount must be less than or equal to the amount in the ticket.\n    //\n    // For simplicity, this function requires that the entire liquid ticket is consumed if the amounts are equal.\n    // In a production contract, partial updates would be handled more gracefully.\n    //\n    // Acquires the global resource StakingPool.\n    public fun unstake(user: &signer, ticket: LiquidTicket, unstake_amount: u64, now: u64) acquires StakingPool {\n        // Ensure that the ticket belongs to the caller.\n        assert!(ticket.owner == signer::address_of(user), 100);\n        // Ensure that the lock period has expired.\n        assert!(now >= ticket.lock_until, 101);\n        // Borrow the pool using the address stored in the ticket.\n        let pool_ref = borrow_global_mut<StakingPool>(ticket.pool_addr);\n        // Ensure the unstake amount does not exceed the ticket amount.\n        assert!(unstake_amount <= ticket.amount, 102);\n        pool_ref.total_stake = pool_ref.total_stake - unstake_amount;\n        if (ticket.amount == unstake_amount) {\n            // Full unstake: the ticket is consumed.\n            // In Move, resources that are not moved to any storage are dropped automatically.\n            // Here, the liquid ticket is simply not moved forward.\n            // (No further action is required to destroy the resource.)\n            // The caller would receive SUI coins in a complete implementation.\n            ()\n        } else {\n            // Partial unstake: update the ticket with the reduced amount.\n            let new_ticket = LiquidTicket {\n                id: ticket.id,\n                owner: ticket.owner,\n                amount: ticket.amount - unstake_amount,\n                pool_addr: ticket.pool_addr,\n                lock_until: ticket.lock_until,\n            };\n            // Deposit the updated ticket back to the user's account.\n            move_to<LiquidTicket>(user, new_ticket);\n        }\n        // In a complete implementation, the unstaked SUI would be transferred to the user.\n    }\n\n    //////////////////////////////////////////////////////////////////////\n    // Delegation Functionality\n    //////////////////////////////////////////////////////////////////////\n\n    // Delegate a portion of the stake to a validator.\n    // Only the pool admin can perform delegation.\n    //\n    // Acquires the global resource StakingPool.\n    public fun delegate(admin: &signer, pool_addr: address, validator: address, delegation_amount: u64) acquires StakingPool {\n        let pool_ref = borrow_global_mut<StakingPool>(pool_addr);\n        // Ensure that only the admin can delegate.\n        assert!(signer::address_of(admin) == pool_ref.admin, 200);\n        // Create a new delegation entry with a fresh UID.\n        let delegation = Delegation {\n            id: UID::new(),\n            validator: validator,\n            amount: delegation_amount,\n        };\n        vector::push_back(&mut pool_ref.delegations, delegation);\n        // Simulate delegation by reducing the pool's total stake.\n        pool_ref.total_stake = pool_ref.total_stake - delegation_amount;\n    }\n\n    //////////////////////////////////////////////////////////////////////\n    // Rewards Distribution Functionality\n    //////////////////////////////////////////////////////////////////////\n\n    // Distribute rewards to the staking pool.\n    // Only the pool admin can trigger the distribution.\n    //\n    // Acquires the global resource StakingPool.\n    public fun distribute_rewards(admin: &signer, pool_addr: address, rewards_amount: u64) acquires StakingPool {\n        let pool_ref = borrow_global_mut<StakingPool>(pool_addr);\n        // Only the admin is allowed to distribute rewards.\n        assert!(signer::address_of(admin) == pool_ref.admin, 201);\n        pool_ref.rewards = pool_ref.rewards + rewards_amount;\n        // In a full implementation, new SUI coins would be minted and distributed to stakers.\n    }\n\n    //////////////////////////////////////////////////////////////////////\n    // Utility Function\n    //////////////////////////////////////////////////////////////////////\n\n    // Find the index of a delegation for a given validator within a vector of delegations.\n    // Returns the index if found; otherwise, returns the length of the vector.\n    public fun index_of_validator(delegations: &vector<Delegation>, validator: address): u64 {\n        let len = vector::length(delegations);\n        let i = 0;\n        while (i < len) {\n            let delegation_ref = vector::borrow(delegations, i);\n            if (delegation_ref.validator == validator) {\n                return i;\n            }\n            i = i + 1;\n        }\n        return len;\n    }\n\n    //////////////////////////////////////////////////////////////////////\n    // UID helper\n    //////////////////////////////////////////////////////////////////////\n\n    // For simulation purposes, we assume that UID::new() is a function provided by the Sui framework\n    // that generates a unique identifier. Here we simply call it without arguments.\n    //\n    // In an actual deployment, UID is created by the runtime and no additional code is needed.\n    //\n    // The calls to UID::new() above are assumed to be valid in the context of the Sui framework.\n}\n",
      "output": "UPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git\nINCLUDING DEPENDENCY Sui\nINCLUDING DEPENDENCY MoveStdlib\nBUILDING TempContract\nwarning[W02021]: duplicate alias\n  \u250c\u2500 ./sources/temp_contract.move:3:14\n  \u2502\n3 \u2502     use std::vector;\n  \u2502              ^^^^^^ Unnecessary alias 'vector' for module 'std::vector'. This alias is provided by default\n  \u2502\n  = This warning can be suppressed with '#[allow(duplicate_alias)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nerror[E03002]: unbound module\n  \u250c\u2500 ./sources/temp_contract.move:4:9\n  \u2502\n4 \u2502     use std::signer;\n  \u2502         ^^^^^^^^^^^ Invalid 'use'. Unbound module: 'std::signer'\n\nwarning[W02021]: duplicate alias\n  \u250c\u2500 ./sources/temp_contract.move:7:22\n  \u2502\n7 \u2502     use sui::object::UID;\n  \u2502                      ^^^ Unnecessary alias 'UID' for module member 'sui::object::UID'. This alias is provided by default\n  \u2502\n  = This warning can be suppressed with '#[allow(duplicate_alias)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nerror[E01002]: unexpected token\n   \u250c\u2500 ./sources/temp_contract.move:17:12\n   \u2502\n17 \u2502     public resource struct StakingPool has key {\n   \u2502            ^^^^^^^^\n   \u2502            \u2502\n   \u2502            Unexpected 'resource'\n   \u2502            Expected a module member: 'spec', 'use', 'friend', 'const', 'fun', 'struct', or 'enum'\n\nerror[E01003]: invalid modifier\n   \u250c\u2500 ./sources/temp_contract.move:17:21\n   \u2502\n17 \u2502     public resource struct StakingPool has key {\n   \u2502                     ^^^^^^ Invalid struct declaration. Internal struct declarations are not yet supported\n   \u2502\n   = Visibility annotations are required on struct declarations from the Move 2024 edition onwards.\n\nerror[Sui E02007]: invalid object declaration\n   \u250c\u2500 ./sources/temp_contract.move:18:9\n   \u2502\n17 \u2502     public resource struct StakingPool has key {\n   \u2502                                            --- The 'key' ability is used to declare objects in Sui\n18 \u2502         admin: address,\n   \u2502         ^^^^^ Invalid object 'StakingPool'. Structs with the 'key' ability must have 'id: sui::object::UID' as their first field\n\nerror[E05001]: ability constraint not satisfied\n   \u250c\u2500 ./sources/temp_contract.move:22:22\n   \u2502\n22 \u2502         delegations: vector<Delegation>,\n   \u2502                      ^^^^^^^^^^^^^^^^^^\n   \u2502                      \u2502      \u2502\n   \u2502                      \u2502      The type 'vector<0x0::my_module::Delegation>' can have the ability 'store' but the type argument '0x0::my_module::Delegation' does not have the required ability 'store'\n   \u2502                      Invalid field type. The struct was declared with the ability 'key' so all fields require the ability 'store'\n   \u2502                      The type 'vector<0x0::my_module::Delegation>' does not have the ability 'store'\n\nerror[E01002]: unexpected token\n   \u250c\u2500 ./sources/temp_contract.move:27:12\n   \u2502\n27 \u2502     public resource struct Delegation has key {\n   \u2502            ^^^^^^^^\n   \u2502            \u2502\n   \u2502            Unexpected 'resource'\n   \u2502            Expected a module member: 'spec', 'use', 'friend', 'const', 'fun', 'struct', or 'enum'\n\nerror[E01003]: invalid modifier\n   \u250c\u2500 ./sources/temp_contract.move:27:21\n   \u2502\n27 \u2502     public resource struct Delegation has key {\n   \u2502                     ^^^^^^ Invalid struct declaration. Internal struct declarations are not yet supported\n   \u2502\n   = Visibility annotations are required on struct declarations from the Move 2024 edition onwards.\n\nerror[E01002]: unexpected token\n   \u250c\u2500 ./sources/temp_contract.move:35:12\n   \u2502\n35 \u2502     public resource struct LiquidTicket has key {\n   \u2502            ^^^^^^^^\n   \u2502            \u2502\n   \u2502            Unexpected 'resource'\n   \u2502            Expected a module member: 'spec', 'use', 'friend', 'const', 'fun', 'struct', or 'enum'\n\nerror[E01003]: invalid modifier\n   \u250c\u2500 ./sources/temp_contract.move:35:21\n   \u2502\n35 \u2502     public resource struct LiquidTicket has key {\n   \u2502                     ^^^^^^ Invalid struct declaration. Internal struct declarations are not yet supported\n   \u2502\n   = Visibility annotations are required on struct declarations from the Move 2024 edition onwards.\n\nerror[E03006]: unexpected name in this position\n   \u250c\u2500 ./sources/temp_contract.move:52:20\n   \u2502\n52 \u2502             admin: signer::address_of(admin),\n   \u2502                    ^^^^^^ Could not resolve the name 'signer'\n\nerror[E03005]: unbound unscoped name\n   \u250c\u2500 ./sources/temp_contract.move:58:9\n   \u2502\n58 \u2502         move_to<StakingPool>(admin, pool);\n   \u2502         ^^^^^^^ Unbound function 'move_to' in current scope\n\nwarning[W09002]: unused variable\n   \u250c\u2500 ./sources/temp_contract.move:71:22\n   \u2502\n71 \u2502     public fun stake(user: &signer, pool_addr: address, amount: u64, lock_duration: u64, now: u64) acquires StakingPool {\n   \u2502                      ^^^^ Unused parameter 'user'. Consider removing or prefixing with an underscore: '_user'\n   \u2502\n   = This warning can be suppressed with '#[allow(unused_variable)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nwarning[W09002]: unused variable\n   \u250c\u2500 ./sources/temp_contract.move:71:37\n   \u2502\n71 \u2502     public fun stake(user: &signer, pool_addr: address, amount: u64, lock_duration: u64, now: u64) acquires StakingPool {\n   \u2502                                     ^^^^^^^^^ Unused parameter 'pool_addr'. Consider removing or prefixing with an underscore: '_pool_addr'\n   \u2502\n   = This warning can be suppressed with '#[allow(unused_variable)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nwarning[W09002]: unused variable\n   \u250c\u2500 ./sources/temp_contract.move:71:57\n   \u2502\n71 \u2502     public fun stake(user: &signer, pool_addr: address, amount: u64, lock_duration: u64, now: u64) acquires StakingPool {\n   \u2502                                                         ^^^^^^ Unused parameter 'amount'. Consider removing or prefixing with an underscore: '_amount'\n   \u2502\n   = This warning can be suppressed with '#[allow(unused_variable)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nwarning[W09002]: unused variable\n   \u250c\u2500 ./sources/temp_contract.move:71:70\n   \u2502\n71 \u2502     public fun stake(user: &signer, pool_addr: address, amount: u64, lock_duration: u64, now: u64) acquires StakingPool {\n   \u2502                                                                      ^^^^^^^^^^^^^ Unused parameter 'lock_duration'. Consider removing or prefixing with an underscore: '_lock_duration'\n   \u2502\n   = This warning can be suppressed with '#[allow(unused_variable)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nwarning[W09002]: unused variable\n   \u250c\u2500 ./sources/temp_contract.move:71:90\n   \u2502\n71 \u2502     public fun stake(user: &signer, pool_addr: address, amount: u64, lock_duration: u64, now: u64) acquires StakingPool {\n   \u2502                                                                                          ^^^ Unused parameter 'now'. Consider removing or prefixing with an underscore: '_now'\n   \u2502\n   = This warning can be suppressed with '#[allow(unused_variable)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nerror[E01002]: unexpected token\n   \u250c\u2500 ./sources/temp_contract.move:71:100\n   \u2502\n71 \u2502     public fun stake(user: &signer, pool_addr: address, amount: u64, lock_duration: u64, now: u64) acquires StakingPool {\n   \u2502                                                                                                    ^^^^^^^^\n   \u2502                                                                                                    \u2502\n   \u2502                                                                                                    Unexpected 'acquires'\n   \u2502                                                                                                    Expected '{'\n\nwarning[W09002]: unused variable\n   \u250c\u2500 ./sources/temp_contract.move:94:24\n   \u2502\n94 \u2502     public fun unstake(user: &signer, ticket: LiquidTicket, unstake_amount: u64, now: u64) acquires StakingPool {\n   \u2502                        ^^^^ Unused parameter 'user'. Consider removing or prefixing with an underscore: '_user'\n   \u2502\n   = This warning can be suppressed with '#[allow(unused_variable)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nwarning[W09002]: unused variable\n   \u250c\u2500 ./sources/temp_contract.move:94:39\n   \u2502\n94 \u2502     public fun unstake(user: &signer, ticket: LiquidTicket, unstake_amount: u64, now: u64) acquires StakingPool {\n   \u2502                                       ^^^^^^ Unused parameter 'ticket'. Consider removing or prefixing with an underscore: '_ticket'\n   \u2502\n   = This warning can be suppressed with '#[allow(unused_variable)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nwarning[W09002]: unused variable\n   \u250c\u2500 ./sources/temp_contract.move:94:61\n   \u2502\n94 \u2502     public fun unstake(user: &signer, ticket: LiquidTicket, unstake_amount: u64, now: u64) acquires StakingPool {\n   \u2502                                                             ^^^^^^^^^^^^^^ Unused parameter 'unstake_amount'. Consider removing or prefixing with an underscore: '_unstake_amount'\n   \u2502\n   = This warning can be suppressed with '#[allow(unused_variable)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nwarning[W09002]: unused variable\n   \u250c\u2500 ./sources/temp_contract.move:94:82\n   \u2502\n94 \u2502     public fun unstake(user: &signer, ticket: LiquidTicket, unstake_amount: u64, now: u64) acquires StakingPool {\n   \u2502                                                                                  ^^^ Unused parameter 'now'. Consider removing or prefixing with an underscore: '_now'\n   \u2502\n   = This warning can be suppressed with '#[allow(unused_variable)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nerror[E01002]: unexpected token\n   \u250c\u2500 ./sources/temp_contract.move:94:92\n   \u2502\n94 \u2502     public fun unstake(user: &signer, ticket: LiquidTicket, unstake_amount: u64, now: u64) acquires StakingPool {\n   \u2502                                                                                            ^^^^^^^^\n   \u2502                                                                                            \u2502\n   \u2502                                                                                            Unexpected 'acquires'\n   \u2502                                                                                            Expected '{'\n\nwarning[W09002]: unused variable\n    \u250c\u2500 ./sources/temp_contract.move:134:25\n    \u2502\n134 \u2502     public fun delegate(admin: &signer, pool_addr: address, validator: address, delegation_amount: u64) acquires StakingPool {\n    \u2502                         ^^^^^ Unused parameter 'admin'. Consider removing or prefixing with an underscore: '_admin'\n    \u2502\n    = This warning can be suppressed with '#[allow(unused_variable)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nwarning[W09002]: unused variable\n    \u250c\u2500 ./sources/temp_contract.move:134:41\n    \u2502\n134 \u2502     public fun delegate(admin: &signer, pool_addr: address, validator: address, delegation_amount: u64) acquires StakingPool {\n    \u2502                                         ^^^^^^^^^ Unused parameter 'pool_addr'. Consider removing or prefixing with an underscore: '_pool_addr'\n    \u2502\n    = This warning can be suppressed with '#[allow(unused_variable)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nwarning[W09002]: unused variable\n    \u250c\u2500 ./sources/temp_contract.move:134:61\n    \u2502\n134 \u2502     public fun delegate(admin: &signer, pool_addr: address, validator: address, delegation_amount: u64) acquires StakingPool {\n    \u2502                                                             ^^^^^^^^^ Unused parameter 'validator'. Consider removing or prefixing with an underscore: '_validator'\n    \u2502\n    = This warning can be suppressed with '#[allow(unused_variable)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nwarning[W09002]: unused variable\n    \u250c\u2500 ./sources/temp_contract.move:134:81\n    \u2502\n134 \u2502     public fun delegate(admin: &signer, pool_addr: address, validator: address, delegation_amount: u64) acquires StakingPool {\n    \u2502                                                                                 ^^^^^^^^^^^^^^^^^ Unused parameter 'delegation_amount'. Consider removing or prefixing with an underscore: '_delegation_amount'\n    \u2502\n    = This warning can be suppressed with '#[allow(unused_variable)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nerror[E01002]: unexpected token\n    \u250c\u2500 ./sources/temp_contract.move:134:105\n    \u2502\n134 \u2502     public fun delegate(admin: &signer, pool_addr: address, validator: address, delegation_amount: u64) acquires StakingPool {\n    \u2502                                                                                                         ^^^^^^^^\n    \u2502                                                                                                         \u2502\n    \u2502                                                                                                         Unexpected 'acquires'\n    \u2502                                                                                                         Expected '{'\n\nwarning[W09002]: unused variable\n    \u250c\u2500 ./sources/temp_contract.move:157:35\n    \u2502\n157 \u2502     public fun distribute_rewards(admin: &signer, pool_addr: address, rewards_amount: u64) acquires StakingPool {\n    \u2502                                   ^^^^^ Unused parameter 'admin'. Consider removing or prefixing with an underscore: '_admin'\n    \u2502\n    = This warning can be suppressed with '#[allow(unused_variable)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nwarning[W09002]: unused variable\n    \u250c\u2500 ./sources/temp_contract.move:157:51\n    \u2502\n157 \u2502     public fun distribute_rewards(admin: &signer, pool_addr: address, rewards_amount: u64) acquires StakingPool {\n    \u2502                                                   ^^^^^^^^^ Unused parameter 'pool_addr'. Consider removing or prefixing with an underscore: '_pool_addr'\n    \u2502\n    = This warning can be suppressed with '#[allow(unused_variable)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nwarning[W09002]: unused variable\n    \u250c\u2500 ./sources/temp_contract.move:157:71\n    \u2502\n157 \u2502     public fun distribute_rewards(admin: &signer, pool_addr: address, rewards_amount: u64) acquires StakingPool {\n    \u2502                                                                       ^^^^^^^^^^^^^^ Unused parameter 'rewards_amount'. Consider removing or prefixing with an underscore: '_rewards_amount'\n    \u2502\n    = This warning can be suppressed with '#[allow(unused_variable)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nerror[E01002]: unexpected token\n    \u250c\u2500 ./sources/temp_contract.move:157:92\n    \u2502\n157 \u2502     public fun distribute_rewards(admin: &signer, pool_addr: address, rewards_amount: u64) acquires StakingPool {\n    \u2502                                                                                            ^^^^^^^^\n    \u2502                                                                                            \u2502\n    \u2502                                                                                            Unexpected 'acquires'\n    \u2502                                                                                            Expected '{'\n\nerror[E01002]: unexpected token\n    \u250c\u2500 ./sources/temp_contract.move:179:13\n    \u2502\n179 \u2502             i = i + 1;\n    \u2502             ^\n    \u2502             \u2502\n    \u2502             Unexpected 'i'\n    \u2502             Expected ';'\n\nerror[E01002]: unexpected token\n    \u250c\u2500 ./sources/temp_contract.move:181:9\n    \u2502\n181 \u2502         return len;\n    \u2502         ^^^^^^\n    \u2502         \u2502\n    \u2502         Unexpected 'return'\n    \u2502         Expected ';'\n\nerror[E04007]: incompatible types\n    \u250c\u2500 ./sources/temp_contract.move:181:19\n    \u2502\n171 \u2502     public fun index_of_validator(delegations: &vector<Delegation>, validator: address): u64 {\n    \u2502                                                                                          --- Expected: 'u64'\n    \u00b7\n181 \u2502         return len;\n    \u2502                   ^\n    \u2502                   \u2502\n    \u2502                   Invalid return expression\n    \u2502                   Given: '()'\n\n",
      "metadata": {
        "iteration": 3,
        "timestamp": 1740790050.104404,
        "error_stats": {
          "errors": 36,
          "compiler_warnings": 18,
          "linter_warnings": 0
        },
        "error_codes": {
          "W21002": {
            "count": 2,
            "message": "duplicate alias",
            "level": "Warning"
          },
          "E02003": {
            "count": 1,
            "message": "unbound module",
            "level": "BlockingError"
          },
          "N02001": {
            "count": 9,
            "message": "unexpected token",
            "level": "NonblockingError"
          },
          "N03001": {
            "count": 3,
            "message": "invalid modifier",
            "level": "NonblockingError"
          },
          "N07002": {
            "count": 1,
            "message": "invalid object declaration",
            "level": "NonblockingError"
          },
          "N01005": {
            "count": 1,
            "message": "ability constraint not satisfied",
            "level": "NonblockingError"
          },
          "E06003": {
            "count": 1,
            "message": "unexpected name in this position",
            "level": "BlockingError"
          },
          "E05003": {
            "count": 1,
            "message": "unbound unscoped name",
            "level": "BlockingError"
          },
          "W02009": {
            "count": 16,
            "message": "unused variable",
            "level": "Warning"
          },
          "E07004": {
            "count": 1,
            "message": "incompatible types",
            "level": "BlockingError"
          }
        }
      }
    },
    {
      "input": "module 0x0::my_module {\n    // Import standard vector module.\n    use vector;\n    // Import the built-in signer module for address_of.\n    use core::signer;\n    // Import UID from the Sui framework.\n    use sui::object::UID;\n\n    ///////////////////////////////////////////////////////////////////////////\n    // DATA STRUCTURES\n    ///////////////////////////////////////////////////////////////////////////\n\n    // The staking pool holds the overall protocol state, including the total staked amount,\n    // accumulated rewards, and delegation records. The 'key' ability makes it an on\u2010chain object.\n    public struct StakingPool has key {\n        // Every Sui object with key ability must have an 'id' field of type UID as the first field.\n        id: UID,\n        admin: address,\n        total_staked: u64,\n        rewards: u64,\n        // Delegations recorded in the pool.\n        delegations: vector<Delegation>\n    }\n\n    // Each delegation is an assignment of a portion of staked funds to a validator.\n    // We add the 'store' ability so that this type can be stored inside another object.\n    public struct Delegation has key, store {\n        id: UID,\n        validator: address,\n        amount: u64\n    }\n\n    // LiquidTicket represents a liquid staking token that a user can redeem later\n    // for unstaking. It includes an unlock time to enforce optional lock periods.\n    public struct LiquidTicket has key, store {\n        id: UID,\n        owner: address,\n        amount: u64,\n        unlock_time: u64\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // INITIALIZATION\n    ///////////////////////////////////////////////////////////////////////////\n\n    // Initializes a new staking pool. Only the caller (admin) controls the pool.\n    public fun init_pool(admin: &signer): StakingPool {\n        StakingPool {\n            id: UID::new(),                      // Create a unique identifier.\n            admin: signer::address_of(admin),    // Set the admin to the caller.\n            total_staked: 0,\n            rewards: 0,\n            delegations: vector::empty<Delegation>()\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // STAKING FUNCTIONS\n    ///////////////////////////////////////////////////////////////////////////\n\n    // Stake native SUI into the pool.\n    // For simplicity in this example, we only update the pool state.\n    // In a full contract, this function would involve coin transfers and minting a liquid ticket.\n    public fun stake(user: &signer, pool: &mut StakingPool, amount: u64, lock_duration: u64, now: u64): () {\n        // Increase the total staked amount.\n        pool.total_staked = pool.total_staked + amount;\n        // Mint a liquid staking token (ticket) representing the user's staked position.\n        let _ticket = LiquidTicket {\n            id: UID::new(),\n            owner: signer::address_of(user),\n            amount: amount,\n            unlock_time: now + lock_duration\n        };\n        // In a full implementation, the ticket would be moved to the user's account.\n        ()\n    }\n\n    // Unstake native SUI using a liquid ticket.\n    // This function decreases the staked amount based on the unstake request.\n    public fun unstake(user: &signer, pool: &mut StakingPool, ticket: LiquidTicket, unstake_amount: u64, now: u64): () {\n        // Validate that the ticket owner is the user initiating unstake.\n        let user_addr = signer::address_of(user);\n        assert!(ticket.owner == user_addr, 100);\n        // In a full implementation, additional checks would be enforced, e.g., unlock time.\n        // Reduce the staked total. (For simplicity, not checking underflow here.)\n        pool.total_staked = pool.total_staked - unstake_amount;\n        // Burn or update the ticket accordingly. Here, we simply drop it.\n        ()\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // DELEGATION FUNCTIONS\n    ///////////////////////////////////////////////////////////////////////////\n\n    // Delegate a portion of the staked funds to a chosen validator.\n    // This function can only be executed by the pool administrator.\n    public fun delegate(admin: &signer, pool: &mut StakingPool, validator: address, delegation_amount: u64): () {\n        // Verify that the caller is the pool admin.\n        let admin_addr = signer::address_of(admin);\n        assert!(admin_addr == pool.admin, 200);\n        // Create a new delegation record.\n        let delegation = Delegation {\n            id: UID::new(),\n            validator: validator,\n            amount: delegation_amount\n        };\n        // Record the delegation in the pool.\n        vector::push_back(&mut pool.delegations, delegation);\n        ()\n    }\n\n    // Distribute staking rewards across existing delegations.\n    // Rewards distribution is done proportionally across delegations.\n    public fun distribute_rewards(admin: &signer, pool: &mut StakingPool, rewards_amount: u64): () {\n        // Verify that the caller is the pool admin.\n        let admin_addr = signer::address_of(admin);\n        assert!(admin_addr == pool.admin, 300);\n        // Update the pool's rewards.\n        pool.rewards = pool.rewards + rewards_amount;\n        // In a full implementation, rewards would be allocated proportionally to each delegation.\n        // Here we simply iterate over all delegation entries (without modifying them).\n        let len = vector::length(&pool.delegations);\n        distribute_rewards_helper(&mut pool.delegations, rewards_amount, 0, len);\n        ()\n    }\n\n    // A recursive helper function to iterate over the delegations.\n    fun distribute_rewards_helper(delegations: &mut vector<Delegation>, rewards_amount: u64, i: u64, len: u64): u64 {\n        if (i >= len) {\n            i\n        } else {\n            // For demonstration purposes, this implementation does not update each delegation.\n            distribute_rewards_helper(delegations, rewards_amount, i + 1, len)\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // HELPER FUNCTIONS\n    ///////////////////////////////////////////////////////////////////////////\n\n    // Recursively finds the index of a delegation entry for a given validator.\n    // If no matching delegation is found, returns the vector length.\n    fun index_of_validator_helper(delegations: &vector<Delegation>, validator: address, idx: u64, len: u64): u64 {\n        if (idx >= len) {\n            len\n        } else {\n            let del_ref = vector::borrow(delegations, idx);\n            if (del_ref.validator == validator) {\n                idx\n            } else {\n                index_of_validator_helper(delegations, validator, idx + 1, len)\n            }\n        }\n    }\n\n    // Returns the index of the delegation for a specific validator.\n    public fun index_of_validator(delegations: &vector<Delegation>, validator: address): u64 {\n        let len = vector::length(delegations);\n        index_of_validator_helper(delegations, validator, 0, len)\n    }\n}",
      "output": "UPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git\nINCLUDING DEPENDENCY Sui\nINCLUDING DEPENDENCY MoveStdlib\nBUILDING TempContract\nerror[E01002]: unexpected token\n  \u250c\u2500 ./sources/temp_contract.move:3:15\n  \u2502\n3 \u2502     use vector;\n  \u2502     ----------^ Unexpected ';'\n  \u2502     \u2502          \n  \u2502     Expected '::' after an address in a use declaration\n\nerror[E03001]: address with no value\n  \u250c\u2500 ./sources/temp_contract.move:5:9\n  \u2502\n5 \u2502     use core::signer;\n  \u2502         ^^^^ address 'core' is not assigned a value\n\nerror[E03002]: unbound module\n  \u250c\u2500 ./sources/temp_contract.move:5:9\n  \u2502\n5 \u2502     use core::signer;\n  \u2502         ^^^^^^^^^^^^ Invalid 'use'. Unbound module: 'core::signer'\n\nwarning[W02021]: duplicate alias\n  \u250c\u2500 ./sources/temp_contract.move:7:22\n  \u2502\n7 \u2502     use sui::object::UID;\n  \u2502                      ^^^ Unnecessary alias 'UID' for module member 'sui::object::UID'. This alias is provided by default\n  \u2502\n  = This warning can be suppressed with '#[allow(duplicate_alias)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nwarning[W09002]: unused variable\n   \u250c\u2500 ./sources/temp_contract.move:47:26\n   \u2502\n47 \u2502     public fun init_pool(admin: &signer): StakingPool {\n   \u2502                          ^^^^^ Unused parameter 'admin'. Consider removing or prefixing with an underscore: '_admin'\n   \u2502\n   = This warning can be suppressed with '#[allow(unused_variable)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nerror[E03006]: unexpected name in this position\n   \u250c\u2500 ./sources/temp_contract.move:49:17\n   \u2502\n49 \u2502             id: UID::new(),                      // Create a unique identifier.\n   \u2502                 ^^^ Invalid construction. Expected an enum\n   \u2502\n   \u250c\u2500 /Users/kz/.move/https___github_com_MystenLabs_sui_git_framework__testnet/crates/sui-framework/packages/sui-framework/sources/object.move:69:15\n   \u2502\n69 \u2502 public struct UID has store {\n   \u2502               --- But 'UID' is an struct\n\nerror[E03006]: unexpected name in this position\n   \u250c\u2500 ./sources/temp_contract.move:50:20\n   \u2502\n50 \u2502             admin: signer::address_of(admin),    // Set the admin to the caller.\n   \u2502                    ^^^^^^ Could not resolve the name 'signer'\n\nwarning[W09002]: unused variable\n   \u250c\u2500 ./sources/temp_contract.move:64:22\n   \u2502\n64 \u2502     public fun stake(user: &signer, pool: &mut StakingPool, amount: u64, lock_duration: u64, now: u64): () {\n   \u2502                      ^^^^ Unused parameter 'user'. Consider removing or prefixing with an underscore: '_user'\n   \u2502\n   = This warning can be suppressed with '#[allow(unused_variable)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nerror[E03006]: unexpected name in this position\n   \u250c\u2500 ./sources/temp_contract.move:69:17\n   \u2502\n69 \u2502             id: UID::new(),\n   \u2502                 ^^^ Invalid construction. Expected an enum\n   \u2502\n   \u250c\u2500 /Users/kz/.move/https___github_com_MystenLabs_sui_git_framework__testnet/crates/sui-framework/packages/sui-framework/sources/object.move:69:15\n   \u2502\n69 \u2502 public struct UID has store {\n   \u2502               --- But 'UID' is an struct\n\nerror[E03006]: unexpected name in this position\n   \u250c\u2500 ./sources/temp_contract.move:70:20\n   \u2502\n70 \u2502             owner: signer::address_of(user),\n   \u2502                    ^^^^^^ Could not resolve the name 'signer'\n\nwarning[W09002]: unused variable\n   \u250c\u2500 ./sources/temp_contract.move:80:24\n   \u2502\n80 \u2502     public fun unstake(user: &signer, pool: &mut StakingPool, ticket: LiquidTicket, unstake_amount: u64, now: u64): () {\n   \u2502                        ^^^^ Unused parameter 'user'. Consider removing or prefixing with an underscore: '_user'\n   \u2502\n   = This warning can be suppressed with '#[allow(unused_variable)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nwarning[W09002]: unused variable\n   \u250c\u2500 ./sources/temp_contract.move:80:106\n   \u2502\n80 \u2502     public fun unstake(user: &signer, pool: &mut StakingPool, ticket: LiquidTicket, unstake_amount: u64, now: u64): () {\n   \u2502                                                                                                          ^^^ Unused parameter 'now'. Consider removing or prefixing with an underscore: '_now'\n   \u2502\n   = This warning can be suppressed with '#[allow(unused_variable)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nerror[E03006]: unexpected name in this position\n   \u250c\u2500 ./sources/temp_contract.move:82:25\n   \u2502\n82 \u2502         let user_addr = signer::address_of(user);\n   \u2502                         ^^^^^^ Could not resolve the name 'signer'\n\nwarning[W09002]: unused variable\n   \u250c\u2500 ./sources/temp_contract.move:97:25\n   \u2502\n97 \u2502     public fun delegate(admin: &signer, pool: &mut StakingPool, validator: address, delegation_amount: u64): () {\n   \u2502                         ^^^^^ Unused parameter 'admin'. Consider removing or prefixing with an underscore: '_admin'\n   \u2502\n   = This warning can be suppressed with '#[allow(unused_variable)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nerror[E03006]: unexpected name in this position\n   \u250c\u2500 ./sources/temp_contract.move:99:26\n   \u2502\n99 \u2502         let admin_addr = signer::address_of(admin);\n   \u2502                          ^^^^^^ Could not resolve the name 'signer'\n\nerror[E03006]: unexpected name in this position\n    \u250c\u2500 ./sources/temp_contract.move:103:17\n    \u2502\n103 \u2502             id: UID::new(),\n    \u2502                 ^^^ Invalid construction. Expected an enum\n    \u2502\n    \u250c\u2500 /Users/kz/.move/https___github_com_MystenLabs_sui_git_framework__testnet/crates/sui-framework/packages/sui-framework/sources/object.move:69:15\n    \u2502\n 69 \u2502 public struct UID has store {\n    \u2502               --- But 'UID' is an struct\n\nwarning[W09002]: unused variable\n    \u250c\u2500 ./sources/temp_contract.move:114:35\n    \u2502\n114 \u2502     public fun distribute_rewards(admin: &signer, pool: &mut StakingPool, rewards_amount: u64): () {\n    \u2502                                   ^^^^^ Unused parameter 'admin'. Consider removing or prefixing with an underscore: '_admin'\n    \u2502\n    = This warning can be suppressed with '#[allow(unused_variable)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nerror[E03006]: unexpected name in this position\n    \u250c\u2500 ./sources/temp_contract.move:116:26\n    \u2502\n116 \u2502         let admin_addr = signer::address_of(admin);\n    \u2502                          ^^^^^^ Could not resolve the name 'signer'\n\n",
      "metadata": {
        "iteration": 4,
        "timestamp": 1740790085.143971,
        "error_stats": {
          "errors": 18,
          "compiler_warnings": 7,
          "linter_warnings": 0
        },
        "error_codes": {
          "N02001": {
            "count": 1,
            "message": "unexpected token",
            "level": "NonblockingError"
          },
          "N01003": {
            "count": 1,
            "message": "address with no value",
            "level": "NonblockingError"
          },
          "E02003": {
            "count": 1,
            "message": "unbound module",
            "level": "BlockingError"
          },
          "W21002": {
            "count": 1,
            "message": "duplicate alias",
            "level": "Warning"
          },
          "W02009": {
            "count": 6,
            "message": "unused variable",
            "level": "Warning"
          },
          "E06003": {
            "count": 8,
            "message": "unexpected name in this position",
            "level": "BlockingError"
          }
        }
      }
    },
    {
      "input": "// This is a complete Sui Move smart contract implementing a simple liquid staking protocol.\n// The module is named \"my_module\" and is deployed under the address 0x0 (temp_addr).\n// It provides functions for initializing a staking pool, staking SUI tokens to obtain a liquid ticket,\n// unstaking (with an optional lock period), delegation to validators, and rewards distribution.\n\naddress 0x0 {\n\nmodule my_module {\n\n    // Import standard vector library.\n    use std::vector;\n    // Import the transaction context to retrieve the caller's address.\n    use sui::tx_context::TxContext;\n\n    // Struct representing the delegation of staked SUI to a validator.\n    // Each delegation record stores the validator's address and the amount delegated.\n    struct Delegation has store {\n        validator: address,\n        amount: u64,\n    }\n\n    // Struct representing the staking pool.\n    // Fields:\n    // - admin: the owner/administrator of this pool. Only the admin can perform privileged actions.\n    // - total_staked: the total amount of SUI staked in the pool.\n    // - total_rewards: the total rewards accrued in the pool.\n    // - ticket_counter: a counter used to assign unique identifiers for each liquid ticket.\n    // - delegations: a vector storing delegation information to validators.\n    struct StakingPool has key, store {\n        admin: address,\n        total_staked: u64,\n        total_rewards: u64,\n        ticket_counter: u64,\n        delegations: vector<Delegation>,\n    }\n\n    // Struct representing a liquid staking ticket issued to users when they stake SUI.\n    // Fields:\n    // - id: a unique identifier for the ticket.\n    // - owner: the address of the ticket owner.\n    // - amount: the amount of SUI staked represented by this ticket.\n    // - lock_until: the timestamp until which unstaking is locked.\n    struct LiquidTicket has store {\n        id: u64,\n        owner: address,\n        amount: u64,\n        lock_until: u64,\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Function: init_pool\n    //\n    // Initializes a new staking pool.\n    // The pool's admin is set to the caller of this function.\n    //\n    // Parameters:\n    // - ctx: Transaction context used to retrieve the caller's address.\n    //\n    // Returns:\n    // - A new instance of StakingPool with initial values.\n    ////////////////////////////////////////////////////////////////////////////////////////////////////\n    public fun init_pool(ctx: &mut TxContext): StakingPool {\n        let admin = TxContext::sender(ctx);\n        StakingPool {\n            admin,\n            total_staked: 0,\n            total_rewards: 0,\n            ticket_counter: 0,\n            delegations: vector::empty<Delegation>(),\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Function: stake\n    //\n    // Stakes a specified amount of SUI, increasing the pool's total staked value and issuing a liquid ticket.\n    // The liquid ticket represents the staked amount and includes a lock period during which unstaking is disabled.\n    //\n    // Parameters:\n    // - ctx: Transaction context used to retrieve the caller's address.\n    // - pool: A mutable reference to the staking pool.\n    // - amount: The amount of SUI to stake.\n    // - lock_duration: The duration (in the same time unit as 'now') for which staking is locked.\n    // - now: The current timestamp.\n    //\n    // Returns:\n    // - A LiquidTicket representing the user's staked position.\n    ////////////////////////////////////////////////////////////////////////////////////////////////////\n    public fun stake(\n        ctx: &mut TxContext,\n        pool: &mut StakingPool,\n        amount: u64,\n        lock_duration: u64,\n        now: u64\n    ): LiquidTicket {\n        let user = TxContext::sender(ctx);\n        // Increase the total staked amount in the pool.\n        pool.total_staked = pool.total_staked + amount;\n        // Generate a unique ticket id and update the counter.\n        let ticket_id = pool.ticket_counter;\n        pool.ticket_counter = pool.ticket_counter + 1;\n        // Calculate the lock expiration time.\n        let lock_until = now + lock_duration;\n        // Issue a liquid ticket to the user.\n        LiquidTicket {\n            id: ticket_id,\n            owner: user,\n            amount,\n            lock_until,\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Function: unstake\n    //\n    // Unstakes a specified amount of SUI from a liquid ticket.\n    // Validates that the caller is the owner of the ticket, the lock period has passed,\n    // and that the unstake amount does not exceed the ticket's staked amount.\n    // The pool's total staked value is reduced accordingly.\n    //\n    // Parameters:\n    // - ctx: Transaction context used to retrieve the caller's address.\n    // - pool: A mutable reference to the staking pool.\n    // - ticket: The liquid ticket being used to unstake.\n    // - unstake_amount: The amount of SUI the user wants to unstake.\n    // - now: The current timestamp.\n    //\n    // Returns:\n    // - A LiquidTicket with the updated staked amount. If the entire amount is unstaked,\n    //   the ticket's amount will be 0.\n    ////////////////////////////////////////////////////////////////////////////////////////////////////\n    public fun unstake(\n        ctx: &mut TxContext,\n        pool: &mut StakingPool,\n        ticket: LiquidTicket,\n        unstake_amount: u64,\n        now: u64\n    ): LiquidTicket {\n        let user = TxContext::sender(ctx);\n        // Ensure that the caller is the owner of the ticket.\n        assert!(ticket.owner == user, 1);\n        // Ensure that the lock period has expired.\n        assert!(now >= ticket.lock_until, 2);\n        // Ensure that the unstake amount does not exceed the ticket amount.\n        assert!(unstake_amount <= ticket.amount, 3);\n        // Adjust the pool's total staked amount.\n        pool.total_staked = pool.total_staked - unstake_amount;\n        let remaining = ticket.amount - unstake_amount;\n        // Return an updated ticket. If the entire amount was unstaked, the ticket will reflect 0 staked.\n        LiquidTicket {\n            id: ticket.id,\n            owner: user,\n            amount: remaining,\n            lock_until: ticket.lock_until,\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Function: delegate\n    //\n    // Allows the pool's admin to delegate a specified amount of staked SUI to a validator.\n    // The function either updates an existing delegation record or creates a new one.\n    //\n    // Parameters:\n    // - ctx: Transaction context used to retrieve the caller's address.\n    // - pool: A mutable reference to the staking pool.\n    // - validator: The address of the validator to delegate to.\n    // - delegation_amount: The amount of SUI to delegate.\n    ////////////////////////////////////////////////////////////////////////////////////////////////////\n    public fun delegate(\n        ctx: &mut TxContext,\n        pool: &mut StakingPool,\n        validator: address,\n        delegation_amount: u64\n    ): () {\n        let caller = TxContext::sender(ctx);\n        // Only the pool admin can perform delegation.\n        assert!(caller == pool.admin, 4);\n        let len = vector::length(&pool.delegations);\n        let found = false;\n        let i = 0;\n        while (i < len) {\n            let d_ref = vector::borrow_mut(&mut pool.delegations, i);\n            if (d_ref.validator == validator) {\n                d_ref.amount = d_ref.amount + delegation_amount;\n                // Mark that delegation was found and updated.\n                found = true;\n                break;\n            };\n            i = i + 1;\n        };\n        // If no existing delegation record was found, create a new one.\n        if (!found) {\n            let new_delegation = Delegation { validator, amount: delegation_amount };\n            vector::push_back(&mut pool.delegations, new_delegation);\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Function: distribute_rewards\n    //\n    // Allows the pool's admin to distribute rewards to the staking pool.\n    // The accrued rewards are added to the pool's total rewards.\n    //\n    // Parameters:\n    // - ctx: Transaction context used to retrieve the caller's address.\n    // - pool: A mutable reference to the staking pool.\n    // - rewards_amount: The amount of rewards to distribute.\n    ////////////////////////////////////////////////////////////////////////////////////////////////////\n    public fun distribute_rewards(\n        ctx: &mut TxContext,\n        pool: &mut StakingPool,\n        rewards_amount: u64\n    ): () {\n        let caller = TxContext::sender(ctx);\n        // Only the pool admin can distribute rewards.\n        assert!(caller == pool.admin, 5);\n        pool.total_rewards = pool.total_rewards + rewards_amount;\n    }\n}\n}",
      "output": "UPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git\nINCLUDING DEPENDENCY Sui\nINCLUDING DEPENDENCY MoveStdlib\nBUILDING TempContract\nerror[E13002]: feature is deprecated in specified edition\n  \u250c\u2500 ./sources/temp_contract.move:6:1\n  \u2502\n6 \u2502 address 0x0 {\n  \u2502 ^^^^^^^ 'address' blocks are deprecated. Use addresses directly in module definitions instead.\n7 \u2502 \n8 \u2502 module my_module {\n  \u2502        --------- Replace with '0x0::my_module'\n\nwarning[W02021]: duplicate alias\n   \u250c\u2500 ./sources/temp_contract.move:11:14\n   \u2502\n11 \u2502     use std::vector;\n   \u2502              ^^^^^^ Unnecessary alias 'vector' for module 'std::vector'. This alias is provided by default\n   \u2502\n   = This warning can be suppressed with '#[allow(duplicate_alias)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nwarning[W02021]: duplicate alias\n   \u250c\u2500 ./sources/temp_contract.move:13:26\n   \u2502\n13 \u2502     use sui::tx_context::TxContext;\n   \u2502                          ^^^^^^^^^ Unnecessary alias 'TxContext' for module member 'sui::tx_context::TxContext'. This alias is provided by default\n   \u2502\n   = This warning can be suppressed with '#[allow(duplicate_alias)]' applied to the 'module' or module member ('const', 'fun', or 'struct')\n\nerror[E01003]: invalid modifier\n   \u250c\u2500 ./sources/temp_contract.move:17:5\n   \u2502\n17 \u2502     struct Delegation has store {\n   \u2502     ^^^^^^ Invalid struct declaration. Internal struct declarations are not yet supported\n   \u2502\n   = Visibility annotations are required on struct declarations from the Move 2024 edition onwards.\n\nerror[E01003]: invalid modifier\n   \u250c\u2500 ./sources/temp_contract.move:29:5\n   \u2502\n29 \u2502     struct StakingPool has key, store {\n   \u2502     ^^^^^^ Invalid struct declaration. Internal struct declarations are not yet supported\n   \u2502\n   = Visibility annotations are required on struct declarations from the Move 2024 edition onwards.\n\nerror[Sui E02007]: invalid object declaration\n   \u250c\u2500 ./sources/temp_contract.move:30:9\n   \u2502\n29 \u2502     struct StakingPool has key, store {\n   \u2502                            --- The 'key' ability is used to declare objects in Sui\n30 \u2502         admin: address,\n   \u2502         ^^^^^ Invalid object 'StakingPool'. Structs with the 'key' ability must have 'id: sui::object::UID' as their first field\n\nerror[E01003]: invalid modifier\n   \u250c\u2500 ./sources/temp_contract.move:43:5\n   \u2502\n43 \u2502     struct LiquidTicket has store {\n   \u2502     ^^^^^^ Invalid struct declaration. Internal struct declarations are not yet supported\n   \u2502\n   = Visibility annotations are required on struct declarations from the Move 2024 edition onwards.\n\nerror[E03006]: unexpected name in this position\n   \u250c\u2500 ./sources/temp_contract.move:63:21\n   \u2502\n63 \u2502         let admin = TxContext::sender(ctx);\n   \u2502                     ^^^^^^^^^ Invalid construction. Expected an enum\n   \u2502\n   \u250c\u2500 /Users/kz/.move/https___github_com_MystenLabs_sui_git_framework__testnet/crates/sui-framework/packages/sui-framework/sources/tx_context.move:21:15\n   \u2502\n21 \u2502 public struct TxContext has drop {\n   \u2502               --------- But 'TxContext' is an struct\n\nerror[E03006]: unexpected name in this position\n   \u250c\u2500 ./sources/temp_contract.move:96:20\n   \u2502\n96 \u2502         let user = TxContext::sender(ctx);\n   \u2502                    ^^^^^^^^^ Invalid construction. Expected an enum\n   \u2502\n   \u250c\u2500 /Users/kz/.move/https___github_com_MystenLabs_sui_git_framework__testnet/crates/sui-framework/packages/sui-framework/sources/tx_context.move:21:15\n   \u2502\n21 \u2502 public struct TxContext has drop {\n   \u2502               --------- But 'TxContext' is an struct\n\nerror[E03006]: unexpected name in this position\n    \u250c\u2500 ./sources/temp_contract.move:139:20\n    \u2502\n139 \u2502         let user = TxContext::sender(ctx);\n    \u2502                    ^^^^^^^^^ Invalid construction. Expected an enum\n    \u2502\n    \u250c\u2500 /Users/kz/.move/https___github_com_MystenLabs_sui_git_framework__testnet/crates/sui-framework/packages/sui-framework/sources/tx_context.move:21:15\n    \u2502\n 21 \u2502 public struct TxContext has drop {\n    \u2502               --------- But 'TxContext' is an struct\n\nerror[E03006]: unexpected name in this position\n    \u250c\u2500 ./sources/temp_contract.move:176:22\n    \u2502\n176 \u2502         let caller = TxContext::sender(ctx);\n    \u2502                      ^^^^^^^^^ Invalid construction. Expected an enum\n    \u2502\n    \u250c\u2500 /Users/kz/.move/https___github_com_MystenLabs_sui_git_framework__testnet/crates/sui-framework/packages/sui-framework/sources/tx_context.move:21:15\n    \u2502\n 21 \u2502 public struct TxContext has drop {\n    \u2502               --------- But 'TxContext' is an struct\n\nerror[E03006]: unexpected name in this position\n    \u250c\u2500 ./sources/temp_contract.move:215:22\n    \u2502\n215 \u2502         let caller = TxContext::sender(ctx);\n    \u2502                      ^^^^^^^^^ Invalid construction. Expected an enum\n    \u2502\n    \u250c\u2500 /Users/kz/.move/https___github_com_MystenLabs_sui_git_framework__testnet/crates/sui-framework/packages/sui-framework/sources/tx_context.move:21:15\n    \u2502\n 21 \u2502 public struct TxContext has drop {\n    \u2502               --------- But 'TxContext' is an struct\n\n",
      "metadata": {
        "iteration": 5,
        "timestamp": 1740790115.809759,
        "error_stats": {
          "errors": 12,
          "compiler_warnings": 2,
          "linter_warnings": 0
        },
        "error_codes": {
          "N02013": {
            "count": 1,
            "message": "feature is deprecated in specified edition",
            "level": "NonblockingError"
          },
          "W21002": {
            "count": 2,
            "message": "duplicate alias",
            "level": "Warning"
          },
          "N03001": {
            "count": 3,
            "message": "invalid modifier",
            "level": "NonblockingError"
          },
          "N07002": {
            "count": 1,
            "message": "invalid object declaration",
            "level": "NonblockingError"
          },
          "E06003": {
            "count": 5,
            "message": "unexpected name in this position",
            "level": "BlockingError"
          }
        }
      }
    }
  ],
  "error_histogram": {
    "W21002": [
      1,
      3,
      2,
      1,
      2
    ],
    "E02003": [
      1,
      0,
      1,
      1,
      0
    ],
    "E03003": [
      2,
      3,
      0,
      0,
      0
    ],
    "N03001": [
      2,
      4,
      3,
      0,
      3
    ],
    "N07002": [
      2,
      1,
      1,
      0,
      1
    ],
    "E04004": [
      9,
      0,
      0,
      0,
      0
    ],
    "E06003": [
      4,
      6,
      1,
      8,
      5
    ],
    "E05003": [
      8,
      8,
      1,
      0,
      0
    ],
    "W02009": [
      5,
      4,
      16,
      6,
      0
    ],
    "E08003": [
      3,
      0,
      0,
      0,
      0
    ],
    "N02001": [
      3,
      0,
      9,
      1,
      0
    ],
    "E10004": [
      8,
      0,
      0,
      0,
      0
    ],
    "E07004": [
      0,
      4,
      1,
      0,
      0
    ],
    "E16004": [
      0,
      2,
      0,
      0,
      0
    ],
    "N01005": [
      0,
      0,
      1,
      0,
      0
    ],
    "N01003": [
      0,
      0,
      0,
      1,
      0
    ],
    "N02013": [
      0,
      0,
      0,
      0,
      1
    ]
  },
  "iterations_data": [
    {
      "iteration": 1,
      "total_errors": 48,
      "error_breakdown": {
        "W21002": {
          "count": 1,
          "message": "duplicate alias",
          "level": "Warning"
        },
        "E02003": {
          "count": 1,
          "message": "unbound module",
          "level": "BlockingError"
        },
        "E03003": {
          "count": 2,
          "message": "unbound module member",
          "level": "BlockingError"
        },
        "N03001": {
          "count": 2,
          "message": "invalid modifier",
          "level": "NonblockingError"
        },
        "N07002": {
          "count": 2,
          "message": "invalid object declaration",
          "level": "NonblockingError"
        },
        "E04004": {
          "count": 9,
          "message": "expected a single non-reference type",
          "level": "BlockingError"
        },
        "E06003": {
          "count": 4,
          "message": "unexpected name in this position",
          "level": "BlockingError"
        },
        "E05003": {
          "count": 8,
          "message": "unbound unscoped name",
          "level": "BlockingError"
        },
        "W02009": {
          "count": 5,
          "message": "unused variable",
          "level": "Warning"
        },
        "E08003": {
          "count": 3,
          "message": "too few type arguments",
          "level": "BlockingError"
        },
        "N02001": {
          "count": 3,
          "message": "unexpected token",
          "level": "NonblockingError"
        },
        "E10004": {
          "count": 8,
          "message": "cannot infer type",
          "level": "BlockingError"
        }
      }
    },
    {
      "iteration": 2,
      "total_errors": 35,
      "error_breakdown": {
        "W21002": {
          "count": 3,
          "message": "duplicate alias",
          "level": "Warning"
        },
        "E03003": {
          "count": 3,
          "message": "unbound module member",
          "level": "BlockingError"
        },
        "N03001": {
          "count": 4,
          "message": "invalid modifier",
          "level": "NonblockingError"
        },
        "N07002": {
          "count": 1,
          "message": "invalid object declaration",
          "level": "NonblockingError"
        },
        "E06003": {
          "count": 6,
          "message": "unexpected name in this position",
          "level": "BlockingError"
        },
        "E05003": {
          "count": 8,
          "message": "unbound unscoped name",
          "level": "BlockingError"
        },
        "E07004": {
          "count": 4,
          "message": "incompatible types",
          "level": "BlockingError"
        },
        "W02009": {
          "count": 4,
          "message": "unused variable",
          "level": "Warning"
        },
        "E16004": {
          "count": 2,
          "message": "too few arguments",
          "level": "BlockingError"
        }
      }
    },
    {
      "iteration": 3,
      "total_errors": 36,
      "error_breakdown": {
        "W21002": {
          "count": 2,
          "message": "duplicate alias",
          "level": "Warning"
        },
        "E02003": {
          "count": 1,
          "message": "unbound module",
          "level": "BlockingError"
        },
        "N02001": {
          "count": 9,
          "message": "unexpected token",
          "level": "NonblockingError"
        },
        "N03001": {
          "count": 3,
          "message": "invalid modifier",
          "level": "NonblockingError"
        },
        "N07002": {
          "count": 1,
          "message": "invalid object declaration",
          "level": "NonblockingError"
        },
        "N01005": {
          "count": 1,
          "message": "ability constraint not satisfied",
          "level": "NonblockingError"
        },
        "E06003": {
          "count": 1,
          "message": "unexpected name in this position",
          "level": "BlockingError"
        },
        "E05003": {
          "count": 1,
          "message": "unbound unscoped name",
          "level": "BlockingError"
        },
        "W02009": {
          "count": 16,
          "message": "unused variable",
          "level": "Warning"
        },
        "E07004": {
          "count": 1,
          "message": "incompatible types",
          "level": "BlockingError"
        }
      }
    },
    {
      "iteration": 4,
      "total_errors": 18,
      "error_breakdown": {
        "N02001": {
          "count": 1,
          "message": "unexpected token",
          "level": "NonblockingError"
        },
        "N01003": {
          "count": 1,
          "message": "address with no value",
          "level": "NonblockingError"
        },
        "E02003": {
          "count": 1,
          "message": "unbound module",
          "level": "BlockingError"
        },
        "W21002": {
          "count": 1,
          "message": "duplicate alias",
          "level": "Warning"
        },
        "W02009": {
          "count": 6,
          "message": "unused variable",
          "level": "Warning"
        },
        "E06003": {
          "count": 8,
          "message": "unexpected name in this position",
          "level": "BlockingError"
        }
      }
    },
    {
      "iteration": 5,
      "total_errors": 12,
      "error_breakdown": {
        "N02013": {
          "count": 1,
          "message": "feature is deprecated in specified edition",
          "level": "NonblockingError"
        },
        "W21002": {
          "count": 2,
          "message": "duplicate alias",
          "level": "Warning"
        },
        "N03001": {
          "count": 3,
          "message": "invalid modifier",
          "level": "NonblockingError"
        },
        "N07002": {
          "count": 1,
          "message": "invalid object declaration",
          "level": "NonblockingError"
        },
        "E06003": {
          "count": 5,
          "message": "unexpected name in this position",
          "level": "BlockingError"
        }
      }
    }
  ],
  "total_iterations": 5
}